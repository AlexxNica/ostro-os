From 23eb4c4051c7acb2babd4b224ef85cc8ee8fa511 Mon Sep 17 00:00:00 2001
From: Martin Jansa <Martin.Jansa@gmail.com>
Date: Thu, 25 Nov 2010 16:49:53 +0100
Subject: [PATCH] video out for omapfb support

Upstream-Status: Pending
Signed-off-by: Martin Jansa <Martin.Jansa@gmail.com>
---
 Makefile               |    2 +-
 libvo/video_out.c      |    2 +
 libvo/video_out.c.orig |  654 ++++++++++++++++++++++++++++++++++++++++++++++++
 libvo/vo_omapfb.c      |  591 +++++++++++++++++++++++++++++++++++++++++++
 libvo/yuv.S            |  170 +++++++++++++
 5 files changed, 1418 insertions(+), 1 deletions(-)
 create mode 100644 libvo/video_out.c.orig
 create mode 100644 libvo/vo_omapfb.c
 create mode 100644 libvo/yuv.S

diff --git a/Makefile b/Makefile
index 28c6383..b023136 100644
--- a/Makefile
+++ b/Makefile
@@ -451,7 +451,7 @@ SRCS_MPLAYER-$(DIRECTFB)     += libvo/vo_directfb2.c libvo/vo_dfbmga.c
 SRCS_MPLAYER-$(DIRECTX)      += libao2/ao_dsound.c libvo/vo_directx.c
 SRCS_MPLAYER-$(DXR3)         += libvo/vo_dxr3.c
 SRCS_MPLAYER-$(ESD)          += libao2/ao_esd.c
-SRCS_MPLAYER-$(FBDEV)        += libvo/vo_fbdev.c libvo/vo_fbdev2.c
+SRCS_MPLAYER-$(FBDEV)        += libvo/vo_fbdev.c libvo/vo_fbdev2.c libvo/vo_omapfb.c libvo/yuv.S
 SRCS_MPLAYER-$(FFMPEG)       += libvo/vo_png.c
 SRCS_MPLAYER-$(GGI)          += libvo/vo_ggi.c
 SRCS_MPLAYER-$(GIF)          += libvo/vo_gif89a.c
diff --git a/libvo/video_out.c b/libvo/video_out.c
index 2ed0c86..fc9a1cd 100644
--- a/libvo/video_out.c
+++ b/libvo/video_out.c
@@ -95,6 +95,7 @@ extern struct vo_driver video_out_null;
 extern struct vo_driver video_out_bl;
 extern struct vo_driver video_out_fbdev;
 extern struct vo_driver video_out_fbdev2;
+extern struct vo_driver video_out_omapfb;
 extern struct vo_driver video_out_svga;
 extern struct vo_driver video_out_png;
 extern struct vo_driver video_out_ggi;
@@ -194,6 +195,7 @@ const struct vo_driver *video_out_drivers[] =
 #ifdef CONFIG_FBDEV
         &video_out_fbdev,
         &video_out_fbdev2,
+        &video_out_omapfb,
 #endif
 #ifdef CONFIG_SVGALIB
         &video_out_svga,
diff --git a/libvo/video_out.c.orig b/libvo/video_out.c.orig
new file mode 100644
index 0000000..2ed0c86
--- /dev/null
+++ b/libvo/video_out.c.orig
@@ -0,0 +1,654 @@
+/*
+ * libvo common functions, variables used by many/all drivers.
+ *
+ * This file is part of MPlayer.
+ *
+ * MPlayer is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * MPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with MPlayer; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <stdbool.h>
+
+#include <unistd.h>
+//#include <sys/mman.h>
+
+#include "config.h"
+#include "options.h"
+#include "talloc.h"
+#include "video_out.h"
+#include "aspect.h"
+#include "geometry.h"
+#include "old_vo_wrapper.h"
+#include "input/input.h"
+#include "mp_fifo.h"
+
+
+#include "mp_msg.h"
+
+#include "osdep/shmem.h"
+#ifdef CONFIG_X11
+#include "x11_common.h"
+#endif
+
+int xinerama_screen = -1;
+int xinerama_x;
+int xinerama_y;
+
+int vo_nomouse_input = 0;
+int vo_grabpointer = 1;
+int vo_doublebuffering = 1;
+int vo_vsync = 0;
+int vo_fs = 0;
+int vo_fsmode = 0;
+float vo_panscan = 0.0f;
+int vo_adapter_num=0;
+int vo_refresh_rate=0;
+int vo_keepaspect=1;
+int vo_rootwin=0;
+int vo_border=1;
+int64_t WinID = -1;
+
+int vo_pts=0; // for hw decoding
+float vo_fps=0;
+
+char *vo_subdevice = NULL;
+int vo_directrendering=0;
+
+int vo_colorkey = 0x0000ff00; // default colorkey is green
+                              // (0xff000000 means that colorkey has been disabled)
+
+
+//
+// Externally visible list of all vo drivers
+//
+extern struct vo_driver video_out_mga;
+extern struct vo_driver video_out_xmga;
+extern struct vo_driver video_out_x11;
+extern struct vo_driver video_out_xover;
+extern struct vo_driver video_out_vdpau;
+extern struct vo_driver video_out_xv;
+extern struct vo_driver video_out_gl_nosw;
+extern struct vo_driver video_out_gl;
+extern struct vo_driver video_out_gl_sdl;
+extern struct vo_driver video_out_dga;
+extern struct vo_driver video_out_sdl;
+extern struct vo_driver video_out_3dfx;
+extern struct vo_driver video_out_tdfxfb;
+extern struct vo_driver video_out_s3fb;
+extern struct vo_driver video_out_wii;
+extern struct vo_driver video_out_null;
+extern struct vo_driver video_out_bl;
+extern struct vo_driver video_out_fbdev;
+extern struct vo_driver video_out_fbdev2;
+extern struct vo_driver video_out_svga;
+extern struct vo_driver video_out_png;
+extern struct vo_driver video_out_ggi;
+extern struct vo_driver video_out_aa;
+extern struct vo_driver video_out_caca;
+extern struct vo_driver video_out_mpegpes;
+extern struct vo_driver video_out_yuv4mpeg;
+extern struct vo_driver video_out_direct3d;
+extern struct vo_driver video_out_directx;
+extern struct vo_driver video_out_kva;
+extern struct vo_driver video_out_dxr3;
+extern struct vo_driver video_out_ivtv;
+extern struct vo_driver video_out_v4l2;
+extern struct vo_driver video_out_jpeg;
+extern struct vo_driver video_out_gif89a;
+extern struct vo_driver video_out_vesa;
+extern struct vo_driver video_out_directfb;
+extern struct vo_driver video_out_dfbmga;
+extern struct vo_driver video_out_tdfx_vid;
+extern struct vo_driver video_out_xvr100;
+extern struct vo_driver video_out_tga;
+extern struct vo_driver video_out_corevideo;
+extern struct vo_driver video_out_quartz;
+extern struct vo_driver video_out_pnm;
+extern struct vo_driver video_out_md5sum;
+extern struct vo_driver video_out_glamo;
+
+const struct vo_driver *video_out_drivers[] =
+{
+#ifdef CONFIG_XVR100
+        &video_out_xvr100,
+#endif
+#ifdef CONFIG_TDFX_VID
+        &video_out_tdfx_vid,
+#endif
+#ifdef CONFIG_DIRECTX
+        &video_out_directx,
+#endif
+#ifdef CONFIG_DIRECT3D
+        &video_out_direct3d,
+#endif
+#ifdef CONFIG_KVA
+        &video_out_kva,
+#endif
+#ifdef CONFIG_COREVIDEO
+        &video_out_corevideo,
+#endif
+#ifdef CONFIG_QUARTZ
+        &video_out_quartz,
+#endif
+#ifdef CONFIG_XMGA
+        &video_out_xmga,
+#endif
+#ifdef CONFIG_MGA
+        &video_out_mga,
+#endif
+#ifdef CONFIG_TDFXFB
+        &video_out_tdfxfb,
+#endif
+#ifdef CONFIG_S3FB
+        &video_out_s3fb,
+#endif
+#ifdef CONFIG_WII
+        &video_out_wii,
+#endif
+#ifdef CONFIG_3DFX
+        &video_out_3dfx,
+#endif
+#if CONFIG_VDPAU
+        &video_out_vdpau,
+#endif
+#ifdef CONFIG_XV
+        &video_out_xv,
+#endif
+#ifdef CONFIG_X11
+#ifdef CONFIG_GL
+        &video_out_gl_nosw,
+#endif
+        &video_out_x11,
+        &video_out_xover,
+#endif
+#ifdef CONFIG_SDL
+        &video_out_sdl,
+#endif
+#ifdef CONFIG_GL
+        &video_out_gl,
+#endif
+#ifdef CONFIG_GL_SDL
+        &video_out_gl_sdl,
+#endif
+#ifdef CONFIG_DGA
+        &video_out_dga,
+#endif
+#ifdef CONFIG_GGI
+        &video_out_ggi,
+#endif
+#ifdef CONFIG_FBDEV
+        &video_out_fbdev,
+        &video_out_fbdev2,
+#endif
+#ifdef CONFIG_SVGALIB
+        &video_out_svga,
+#endif
+#ifdef CONFIG_AA
+        &video_out_aa,
+#endif
+#ifdef CONFIG_CACA
+        &video_out_caca,
+#endif
+#ifdef CONFIG_DXR3
+        &video_out_dxr3,
+#endif
+#ifdef CONFIG_IVTV
+        &video_out_ivtv,
+#endif
+#ifdef CONFIG_V4L2_DECODER
+        &video_out_v4l2,
+#endif
+#ifdef CONFIG_BL
+        &video_out_bl,
+#endif
+#ifdef CONFIG_VESA
+        &video_out_vesa,
+#endif
+#ifdef CONFIG_DIRECTFB
+        &video_out_dfbmga,
+#endif
+        &video_out_null,
+        // should not be auto-selected
+#ifdef CONFIG_DIRECTFB
+        // vo directfb can call exit() if initialization fails
+        &video_out_directfb,
+#endif
+        &video_out_mpegpes,
+#ifdef CONFIG_YUV4MPEG
+        &video_out_yuv4mpeg,
+#endif
+#ifdef CONFIG_FFMPEG
+        &video_out_png,
+#endif
+#ifdef CONFIG_JPEG
+        &video_out_jpeg,
+#endif
+#ifdef CONFIG_GIF
+        &video_out_gif89a,
+#endif
+#ifdef CONFIG_TGA
+        &video_out_tga,
+#endif
+#ifdef CONFIG_PNM
+        &video_out_pnm,
+#endif
+#ifdef CONFIG_MD5SUM
+        &video_out_md5sum,
+#endif
+#ifdef CONFIG_GLAMO
+        &video_out_glamo,
+#endif
+        NULL
+};
+
+
+static int vo_preinit(struct vo *vo, const char *arg)
+{
+    return vo->driver->preinit(vo, arg);
+}
+
+int vo_control(struct vo *vo, uint32_t request, void *data)
+{
+    return vo->driver->control(vo, request, data);
+}
+
+// Return -1 if driver appears not to support a draw_image interface,
+// 0 otherwise (whether the driver actually drew something or not).
+int vo_draw_image(struct vo *vo, struct mp_image *mpi, double pts)
+{
+    if (!vo->config_ok)
+        return 0;
+    if (vo->driver->buffer_frames) {
+        vo->driver->draw_image(vo, mpi, pts);
+        return 0;
+    }
+    vo->frame_loaded = true;
+    vo->next_pts = pts;
+    if (vo_control(vo, VOCTRL_DRAW_IMAGE, mpi) == VO_NOTIMPL)
+        return -1;
+    return 0;
+}
+
+int vo_get_buffered_frame(struct vo *vo, bool eof)
+{
+    if (!vo->config_ok)
+        return -1;
+    if (vo->frame_loaded)
+        return 0;
+    if (!vo->driver->buffer_frames)
+        return -1;
+    vo->driver->get_buffered_frame(vo, eof);
+    return vo->frame_loaded ? 0 : -1;
+}
+
+void vo_skip_frame(struct vo *vo)
+{
+    vo->frame_loaded = false;
+}
+
+int vo_draw_frame(struct vo *vo, uint8_t *src[])
+{
+    assert(!vo->driver->is_new);
+    if (!vo->config_ok)
+        return 0;
+    return old_vo_draw_frame(vo, src);
+}
+
+int vo_draw_slice(struct vo *vo, uint8_t *src[], int stride[], int w, int h, int x, int y)
+{
+    return vo->driver->draw_slice(vo, src, stride, w, h, x, y);
+}
+
+void vo_draw_osd(struct vo *vo, struct osd_state *osd)
+{
+    if (!vo->config_ok)
+        return;
+    vo->driver->draw_osd(vo, osd);
+}
+
+void vo_flip_page(struct vo *vo, unsigned int pts_us, int duration)
+{
+    if (!vo->config_ok)
+        return;
+    vo->frame_loaded = false;
+    vo->next_pts = MP_NOPTS_VALUE;
+    if (vo->driver->flip_page_timed)
+        vo->driver->flip_page_timed(vo, pts_us, duration);
+    else
+        vo->driver->flip_page(vo);
+}
+
+void vo_check_events(struct vo *vo)
+{
+    if (!vo->config_ok) {
+        if (vo->registered_fd != -1)
+            mp_input_rm_key_fd(vo->input_ctx, vo->registered_fd);
+        vo->registered_fd = -1;
+        return;
+    }
+    vo->driver->check_events(vo);
+}
+
+void vo_seek_reset(struct vo *vo)
+{
+    vo_control(vo, VOCTRL_RESET, NULL);
+    vo->frame_loaded = false;
+}
+
+void vo_destroy(struct vo *vo)
+{
+    if (vo->registered_fd != -1)
+        mp_input_rm_key_fd(vo->input_ctx, vo->registered_fd);
+    vo->driver->uninit(vo);
+    talloc_free(vo);
+}
+
+void list_video_out(void)
+{
+    int i = 0;
+    mp_tmsg(MSGT_CPLAYER, MSGL_INFO, "Available video output drivers:\n");
+    mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_VIDEO_OUTPUTS\n");
+    while (video_out_drivers[i]) {
+        const vo_info_t *info = video_out_drivers[i++]->info;
+        mp_msg(MSGT_GLOBAL, MSGL_INFO,"\t%s\t%s\n", info->short_name, info->name);
+    }
+    mp_msg(MSGT_GLOBAL, MSGL_INFO,"\n");
+}
+
+struct vo *init_best_video_out(struct MPOpts *opts, struct vo_x11_state *x11,
+                               struct mp_fifo *key_fifo,
+                               struct input_ctx *input_ctx)
+{
+    char **vo_list = opts->video_driver_list;
+    int i;
+    struct vo *vo = talloc_ptrtype(NULL, vo);
+    struct vo initial_values = {
+        .opts = opts,
+        .x11 = x11,
+        .key_fifo = key_fifo,
+        .input_ctx = input_ctx,
+        .event_fd = -1,
+        .registered_fd = -1,
+    };
+    // first try the preferred drivers, with their optional subdevice param:
+    if (vo_list && vo_list[0])
+        while (vo_list[0][0]) {
+            char *name = strdup(vo_list[0]);
+            vo_subdevice = strchr(name,':');
+            if (!strcmp(name, "pgm"))
+                mp_tmsg(MSGT_CPLAYER, MSGL_ERR, "The pgm video output driver has been replaced by -vo pnm:pgmyuv.\n");
+            if (!strcmp(name, "md5"))
+                mp_tmsg(MSGT_CPLAYER, MSGL_ERR, "The md5 video output driver has been replaced by -vo md5sum.\n");
+            if (vo_subdevice) {
+                vo_subdevice[0] = 0;
+                ++vo_subdevice;
+            }
+            for (i = 0; video_out_drivers[i]; i++) {
+                const struct vo_driver *video_driver = video_out_drivers[i];
+                const vo_info_t *info = video_driver->info;
+                if (!strcmp(info->short_name, name)) {
+                    // name matches, try it
+                    *vo = initial_values;
+                    vo->driver = video_driver;
+                    if (!vo_preinit(vo, vo_subdevice)) {
+                        free(name);
+                        return vo; // success!
+                    }
+                    talloc_free_children(vo);
+		}
+	    }
+            // continue...
+            free(name);
+            ++vo_list;
+            if (!(vo_list[0]))
+                return NULL; // do NOT fallback to others
+	}
+    // now try the rest...
+    vo_subdevice = NULL;
+    for (i = 0; video_out_drivers[i]; i++) {
+        const struct vo_driver *video_driver = video_out_drivers[i];
+        *vo = initial_values;
+        vo->driver = video_driver;
+        if (!vo_preinit(vo, vo_subdevice))
+            return vo; // success!
+        talloc_free_children(vo);
+    }
+    free(vo);
+    return NULL;
+}
+
+static int event_fd_callback(void *ctx, int fd)
+{
+    struct vo *vo = ctx;
+    vo_check_events(vo);
+    return MP_INPUT_NOTHING;
+}
+
+int vo_config(struct vo *vo, uint32_t width, uint32_t height,
+                     uint32_t d_width, uint32_t d_height, uint32_t flags,
+                     char *title, uint32_t format)
+{
+    struct MPOpts *opts = vo->opts;
+    panscan_init(vo);
+    aspect_save_orig(vo, width, height);
+    aspect_save_prescale(vo, d_width, d_height);
+
+    if (vo_control(vo, VOCTRL_UPDATE_SCREENINFO, NULL) == VO_TRUE) {
+        aspect(vo, &d_width, &d_height, A_NOZOOM);
+        vo->dx = (int)(opts->vo_screenwidth - d_width) / 2;
+        vo->dy = (int)(opts->vo_screenheight - d_height) / 2;
+        geometry(&vo->dx, &vo->dy, &d_width, &d_height,
+                 opts->vo_screenwidth, opts->vo_screenheight);
+        geometry_xy_changed |= xinerama_screen >= 0;
+        vo->dx += xinerama_x;
+        vo->dy += xinerama_y;
+        vo->dwidth = d_width;
+        vo->dheight = d_height;
+    }
+
+    int ret = vo->driver->config(vo, width, height, d_width, d_height, flags,
+                                 title, format);
+    vo->config_ok = (ret == 0);
+    vo->config_count += vo->config_ok;
+    if (vo->registered_fd == -1 && vo->event_fd != -1 && vo->config_ok) {
+        mp_input_add_key_fd(vo->input_ctx, vo->event_fd, 1, event_fd_callback,
+                            NULL, vo);
+        vo->registered_fd = vo->event_fd;
+    }
+    return ret;
+}
+
+/**
+ * \brief lookup an integer in a table, table must have 0 as the last key
+ * \param key key to search for
+ * \result translation corresponding to key or "to" value of last mapping
+ *         if not found.
+ */
+int lookup_keymap_table(const struct mp_keymap *map, int key) {
+  while (map->from && map->from != key) map++;
+  return map->to;
+}
+
+/**
+ * \brief helper function for the kind of panscan-scaling that needs a source
+ *        and destination rectangle like Direct3D and VDPAU
+ */
+static void src_dst_split_scaling(int src_size, int dst_size, int scaled_src_size,
+                                  int *src_start, int *src_end, int *dst_start, int *dst_end) {
+  if (scaled_src_size > dst_size) {
+    int border = src_size * (scaled_src_size - dst_size) / scaled_src_size;
+    // round to a multiple of 2, this is at least needed for vo_direct3d and ATI cards
+    border = (border / 2 + 1) & ~1;
+    *src_start = border;
+    *src_end   = src_size - border;
+    *dst_start = 0;
+    *dst_end   = dst_size;
+  } else {
+    *src_start = 0;
+    *src_end   = src_size;
+    *dst_start = (dst_size - scaled_src_size) / 2;
+    *dst_end   = *dst_start + scaled_src_size;
+  }
+}
+
+/**
+ * Calculate the appropriate source and destination rectangle to
+ * get a correctly scaled picture, including pan-scan.
+ * Can be extended to take future cropping support into account.
+ *
+ * \param crop specifies the cropping border size in the left, right, top and bottom members, may be NULL
+ * \param borders the border values as e.g. EOSD (ASS) and properly placed DVD highlight support requires,
+ *                may be NULL and only left and top are currently valid.
+ */
+void calc_src_dst_rects(struct vo *vo, int src_width, int src_height,
+                        struct vo_rect *src, struct vo_rect *dst,
+                        struct vo_rect *borders, const struct vo_rect *crop)
+{
+  static const struct vo_rect no_crop = {0, 0, 0, 0, 0, 0};
+  int scaled_width  = 0;
+  int scaled_height = 0;
+  if (!crop) crop = &no_crop;
+  src_width  -= crop->left + crop->right;
+  src_height -= crop->top  + crop->bottom;
+  if (src_width  < 2) src_width  = 2;
+  if (src_height < 2) src_height = 2;
+  dst->left = 0; dst->right  = vo->dwidth;
+  dst->top  = 0; dst->bottom = vo->dheight;
+  src->left = 0; src->right  = src_width;
+  src->top  = 0; src->bottom = src_height;
+  if (borders) {
+    borders->left = 0; borders->top = 0;
+  }
+  if (aspect_scaling()) {
+    aspect(vo, &scaled_width, &scaled_height, A_WINZOOM);
+    panscan_calc_windowed(vo);
+    scaled_width  += vo->panscan_x;
+    scaled_height += vo->panscan_y;
+    if (borders) {
+      borders->left = (vo->dwidth  - scaled_width ) / 2;
+      borders->top  = (vo->dheight - scaled_height) / 2;
+    }
+    src_dst_split_scaling(src_width, vo->dwidth, scaled_width,
+                          &src->left, &src->right, &dst->left, &dst->right);
+    src_dst_split_scaling(src_height, vo->dheight, scaled_height,
+                          &src->top, &src->bottom, &dst->top, &dst->bottom);
+  }
+  src->left += crop->left; src->right  += crop->left;
+  src->top  += crop->top;  src->bottom += crop->top;
+  src->width  = src->right  - src->left;
+  src->height = src->bottom - src->top;
+  dst->width  = dst->right  - dst->left;
+  dst->height = dst->bottom - dst->top;
+}
+
+/**
+ * Generates a mouse movement message if those are enable and sends it
+ * to the "main" MPlayer.
+ *
+ * \param posx new x position of mouse
+ * \param posy new y position of mouse
+ */
+void vo_mouse_movement(struct vo *vo, int posx, int posy)
+{
+  char cmd_str[40];
+  if (!enable_mouse_movements)
+    return;
+  snprintf(cmd_str, sizeof(cmd_str), "set_mouse_pos %i %i", posx, posy);
+  mp_input_queue_cmd(vo->input_ctx, mp_input_parse_cmd(cmd_str));
+}
+
+#if defined(CONFIG_FBDEV) || defined(CONFIG_VESA)
+/* Borrowed from vo_fbdev.c
+Monitor ranges related functions*/
+
+char *monitor_hfreq_str = NULL;
+char *monitor_vfreq_str = NULL;
+char *monitor_dotclock_str = NULL;
+
+float range_max(range_t *r)
+{
+float max = 0;
+
+	for (/* NOTHING */; (r->min != -1 && r->max != -1); r++)
+		if (max < r->max) max = r->max;
+	return max;
+}
+
+
+int in_range(range_t *r, float f)
+{
+	for (/* NOTHING */; (r->min != -1 && r->max != -1); r++)
+		if (f >= r->min && f <= r->max)
+			return 1;
+	return 0;
+}
+
+range_t *str2range(char *s)
+{
+	float tmp_min, tmp_max;
+	char *endptr = s;	// to start the loop
+	range_t *r = NULL;
+	int i;
+
+	if (!s)
+		return NULL;
+	for (i = 0; *endptr; i++) {
+		if (*s == ',')
+			goto out_err;
+		if (!(r = realloc(r, sizeof(*r) * (i + 2)))) {
+			mp_msg(MSGT_GLOBAL, MSGL_WARN,"can't realloc 'r'\n");
+			return NULL;
+		}
+		tmp_min = strtod(s, &endptr);
+		if (*endptr == 'k' || *endptr == 'K') {
+			tmp_min *= 1000.0;
+			endptr++;
+		} else if (*endptr == 'm' || *endptr == 'M') {
+			tmp_min *= 1000000.0;
+			endptr++;
+		}
+		if (*endptr == '-') {
+			tmp_max = strtod(endptr + 1, &endptr);
+			if (*endptr == 'k' || *endptr == 'K') {
+				tmp_max *= 1000.0;
+				endptr++;
+			} else if (*endptr == 'm' || *endptr == 'M') {
+				tmp_max *= 1000000.0;
+				endptr++;
+			}
+			if (*endptr != ',' && *endptr)
+				goto out_err;
+		} else if (*endptr == ',' || !*endptr) {
+			tmp_max = tmp_min;
+		} else
+			goto out_err;
+		r[i].min = tmp_min;
+		r[i].max = tmp_max;
+		if (r[i].min < 0 || r[i].max < 0)
+			goto out_err;
+		s = endptr + 1;
+	}
+	r[i].min = r[i].max = -1;
+	return r;
+out_err:
+	free(r);
+	return NULL;
+}
+
+/* Borrowed from vo_fbdev.c END */
+#endif
diff --git a/libvo/vo_omapfb.c b/libvo/vo_omapfb.c
new file mode 100644
index 0000000..8c927b7
--- /dev/null
+++ b/libvo/vo_omapfb.c
@@ -0,0 +1,591 @@
+/*
+ 
+Copyright (C) 2008 Gregoire Gentil <gregoire@gentil.com>
+Portions Copyright (C) 2009 Howard Chu <hyc@symas.com>
+This file adds an optimized vo output to mplayer for the OMAP platform. This is a first pass and an attempt to help to improve
+media playing on the OMAP platform. The usual disclaimer comes here: this code is provided without any warranty.
+Many bugs and issues still exist. Feed-back is welcome.
+
+This output uses the yuv420_to_yuv422 conversion from Mans Rullgard, and is heavily inspired from the work of Siarhei Siamashka.
+I would like to thank those two persons here, without them this code would certainly not exist.
+
+Two options of the output are available:
+fb_overlay_only (disabled by default): only the overlay is drawn. X11 stuff is ignored.
+dbl_buffer (disabled by default): add double buffering. Some tearsync flags are probably missing in the code.
+
+Syntax is the following:
+mplayer -ao alsa -vo omapfb /test.avi
+mplayer -nosound -vo omapfb:fb_overlay_only:dbl_buffer /test.avi
+
+You need to have two planes on your system. On beagleboard, it means something like: video=omapfb:vram:2M,vram:4M
+
+Known issues:
+1) A green line or some vertical lines (if mplayer decides to draw bands instead of frame) may appear.
+It's an interpolation bug in the color conversion that needs to be fixed
+
+2) The color conversion accepts only 16-pixel multiple for width and height.
+
+3) The scaling down is disabled as the scaling down kernel patch for the OMAP3 platform doesn't seem to work yet.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+
+#include "config.h"
+#include "video_out.h"
+#include "video_out_internal.h"
+#include "fastmemcpy.h"
+#include "sub/sub.h"
+#include "mp_msg.h"
+#include "omapfb.h"
+#include "x11_common.h"
+
+#include "libswscale/swscale.h"
+#include "libmpcodecs/vf_scale.h"
+#include "libavcodec/avcodec.h"
+
+#include "aspect.h"
+
+#include "subopt-helper.h"
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include "wskeys.h"
+
+static vo_info_t info = {
+	"omapfb video driver",
+	"omapfb",
+	"",
+	""
+};
+
+LIBVO_EXTERN(omapfb)
+
+static int fb_overlay_only = 0; // if set, we need only framebuffer overlay, but do not need any x11 code
+static int dbl_buffer = 0;
+static int fullscreen_flag = 0;
+static int plane_ready = 0;
+static uint32_t drwX, drwY;
+
+extern void yuv420_to_yuv422(uint8_t *yuv, uint8_t *y, uint8_t *u, uint8_t *v, int w, int h, int yw, int cw, int dw);
+static struct fb_var_screeninfo sinfo_p0;
+static struct fb_var_screeninfo sinfo;
+static struct fb_var_screeninfo sinfo2;
+static struct fb_fix_screeninfo finfo;
+static struct omapfb_mem_info minfo;
+static struct omapfb_plane_info pinfo;
+static int xoff, yoff;
+
+static struct {
+    unsigned x;
+    unsigned y;
+    uint8_t *buf;
+} fb_pages[2];
+static int dev_fd = -1;
+static int fb_page_flip = 0;
+static int page = 0;
+static void omapfb_update(int x, int y, int out_w, int out_h, int show);
+
+extern void mplayer_put_key( int code );
+#include "osdep/keycodes.h"
+
+#define TRANSPARENT_COLOR_KEY 0xff0
+
+static Display *display = NULL; // pointer to X Display structure.
+static int screen_num; // number of screen to place the window on.
+static Window win = 0;
+static Window parent = 0; // pointer to the newly created window.
+
+/* This is used to intercept window closing requests.  */
+static Atom wm_delete_window;
+
+
+void vo_calc_drwXY(uint32_t *drwX, uint32_t *drwY)
+{
+    *drwX = *drwY = 0;
+    if (vo_fs) {
+        aspect(&vo_dwidth, &vo_dheight, A_ZOOM);
+        vo_dwidth  = FFMIN(vo_dwidth, vo_screenwidth);
+        vo_dheight = FFMIN(vo_dheight, vo_screenheight);
+        *drwX      = (vo_screenwidth - vo_dwidth) / 2;
+        *drwY      = (vo_screenheight - vo_dheight) / 2;
+        mp_msg(MSGT_VO, MSGL_V, "[vo-fs] dx: %d dy: %d dw: %d dh: %d\n",
+               *drwX, *drwY, vo_dwidth, vo_dheight);
+    } else if (WinID == 0) {
+        *drwX = vo_dx;
+        *drwY = vo_dy;
+    }
+}
+
+static void getPrimaryPlaneInfo()
+{
+    int dev_fd = open("/dev/fb0", O_RDWR);
+
+    if (dev_fd == -1) {
+        mp_msg(MSGT_VO, MSGL_FATAL, "[omapfb] Error /dev/fb0\n");
+        return -1;
+    }
+
+    ioctl(dev_fd, FBIOGET_VSCREENINFO, &sinfo_p0);
+    close(dev_fd);
+}
+
+/**
+ * Function to get the offset to be used when in windowed mode
+ * or when using -wid option
+ */
+static void x11_get_window_abs_position(Display *display, Window window,
+                                             int *wx, int *wy, int *ww, int *wh)
+{
+    Window root, parent;
+    Window *child;
+    unsigned int n_children;
+    XWindowAttributes attribs;
+
+    /* Get window attributes */
+    XGetWindowAttributes(display, window, &attribs);
+
+    /* Get relative position of given window */
+    *wx = attribs.x;
+    *wy = attribs.y;
+    if (ww)
+        *ww = attribs.width;
+    if (wh)
+        *wh = attribs.height;
+
+    /* Query window tree information */
+    XQueryTree(display, window, &root, &parent, &child, &n_children);
+    if (parent)
+    {
+      int x, y;
+      /* If we have a parent we must go there and discover his position*/
+      x11_get_window_abs_position(display, parent, &x, &y, NULL, NULL);
+      *wx += x;
+      *wy += y;
+    }
+
+    /* If we had children, free it */
+    if(n_children)
+        XFree(child);
+}
+
+static void x11_check_events(void)
+{
+    int e = vo_x11_check_events(mDisplay);
+
+    if (e & VO_EVENT_RESIZE)
+        vo_calc_drwXY(&drwX, &drwY);
+
+    if (e & VO_EVENT_EXPOSE || e & VO_EVENT_RESIZE)
+    {
+        vo_xv_draw_colorkey(drwX, drwY, vo_dwidth - 1, vo_dheight - 1);
+        omapfb_update(0, 0, 0, 0, 1);
+    }
+}
+
+static void x11_uninit()
+{
+    if (display) {
+        XCloseDisplay(display);
+        display = NULL;
+    }
+}
+
+/**
+ * Initialize framebuffer
+ */
+static int preinit(const char *arg)
+{
+    opt_t subopts[] = {
+        {"fb_overlay_only", OPT_ARG_BOOL, &fb_overlay_only, NULL},
+        {"dbl_buffer", OPT_ARG_BOOL, &dbl_buffer, NULL},
+        {NULL}
+    };
+
+    if (subopt_parse(arg, subopts) != 0) {
+        mp_msg(MSGT_VO, MSGL_FATAL, "[omapfb] unknown suboptions: %s\n", arg);
+        return -1;
+    }
+
+    getPrimaryPlaneInfo();
+    dev_fd = open("/dev/fb1", O_RDWR);
+
+    if (dev_fd == -1) {
+        mp_msg(MSGT_VO, MSGL_FATAL, "[omapfb] Error /dev/fb1\n");
+        return -1;
+    }
+
+    ioctl(dev_fd, FBIOGET_VSCREENINFO, &sinfo);
+    ioctl(dev_fd, OMAPFB_QUERY_PLANE, &pinfo);
+    ioctl(dev_fd, OMAPFB_QUERY_MEM, &minfo);
+
+    if (!fb_overlay_only && !vo_init())
+    {
+        mp_msg(MSGT_VO, MSGL_FATAL, "[omapfb] Could not open X, overlay only...\n");        
+        fb_overlay_only = 1;
+    }
+
+    return 0;
+}
+
+static void omapfb_update(int x, int y, int out_w, int out_h, int show)
+{
+    int xres, yres;
+    if (!fb_overlay_only)
+        x11_get_window_abs_position(mDisplay, vo_window, &x, &y, &out_w, &out_h);
+
+    /* Check for new screen rotation */
+    ioctl(dev_fd, FBIOGET_VSCREENINFO, &sinfo2);
+    if (sinfo2.rotate != sinfo_p0.rotate)
+        getPrimaryPlaneInfo();
+
+    if ( (!x && !y && !out_w && !out_h) ||
+        (out_w < sinfo.xres_virtual / 4) || (out_h < sinfo.yres_virtual / 4) ||  /* HW can't scale down by more than 4x */
+        (out_w > sinfo.xres_virtual * 8) || (out_h > sinfo.yres_virtual * 8) ) { /* HW can't scale up by more than 8x */
+        pinfo.enabled = 0;
+        pinfo.pos_x = 0;
+        pinfo.pos_y = 0;
+        ioctl(dev_fd, OMAPFB_SETUP_PLANE, &pinfo);
+        return;
+    }
+
+    xres = sinfo.xres_virtual;
+    yres = sinfo.yres_virtual;
+
+    /* Handle clipping: if the left or top edge of the window goes
+     * offscreen, clamp the overlay to the left or top edge of the
+     * screen, and set the difference into the frame offset. Also
+     * decrease the overlay size by the offset. The offset must
+     * take window scaling into account as well.
+     *
+     * Likewise, if the right or bottom edge of the window goes
+     * offscreen, clamp the overlay to the right or bottom edge of
+     * the screen, and decrease the overlay size accordingly. The
+     * hardware will truncate the output accordingly, so no offset
+     * is needed. Also take window scaling into account.  -- hyc
+     */
+    if (x < 0) {
+        /* clamp to left edge */
+        xoff = -x;
+        if (out_w != sinfo.xres_virtual) {
+            /* account for scaling */
+            xoff *= sinfo.xres_virtual;
+            xoff /= out_w;
+        }
+        xres -= xoff;
+        out_w += x;
+        x = 0;
+    } else {
+        xoff = 0;
+        if (x + out_w > sinfo_p0.xres) {
+            /* clamp to right edge */
+            int diff = sinfo_p0.xres - x;
+            if (out_w != sinfo.xres_virtual) {
+                /* account for scaling */
+                xres = diff * sinfo.xres_virtual;
+                xres /= out_w;
+            } else {
+                xres = diff;
+            }
+            out_w = diff;
+        }
+    }
+
+    if (y < 0) {
+        /* clamp to top edge - this seldom occurs since the window
+         * titlebar is usually forced to stay visible
+         */
+        yoff = -y;
+        if (out_h != sinfo.yres_virtual) {
+            /* account for scaling */
+            yoff *= sinfo.yres_virtual;
+            yoff /= out_h;
+        }
+        yres -= yoff;
+        out_h += y;
+        y = 0;
+    } else {
+        yoff = 0;
+        if (y + out_h > sinfo_p0.yres) {
+            /* clamp to bottom edge */
+            int diff = sinfo_p0.yres - y;
+            if (out_h != sinfo.yres_virtual) {
+                /* account for scaling */
+                yres = diff * sinfo.yres_virtual;
+                yres /= out_h;
+            } else {
+                yres = diff;
+            }
+            out_h = diff;
+        }
+    }
+
+    if (xoff & 1)
+        xoff++;
+    if (xres & 1)
+        xres--;
+
+    pinfo.enabled = show;
+    pinfo.pos_x = x;
+    pinfo.pos_y = y;
+    pinfo.out_width  = out_w;
+    pinfo.out_height = out_h;
+
+    sinfo.xoffset = fb_pages[page].x + xoff;
+    sinfo.yoffset = fb_pages[page].y + yoff;
+    /* If we had to change the overlay dimensions, update it */
+    if (xres != sinfo2.xres || yres != sinfo2.yres ||
+        sinfo.xoffset != sinfo2.xoffset ||
+        sinfo.yoffset != sinfo2.yoffset) {
+        sinfo.xres = xres;
+        sinfo.yres = yres;
+        sinfo.rotate = sinfo2.rotate;
+        ioctl(dev_fd, FBIOPUT_VSCREENINFO, &sinfo);
+    }
+
+    ioctl(dev_fd, OMAPFB_SETUP_PLANE, &pinfo);
+}
+
+static int config(uint32_t width, uint32_t height, uint32_t d_width,
+		uint32_t d_height, uint32_t flags, char *title,
+		uint32_t format)
+{
+    uint8_t *fbmem;
+    int i;
+    struct omapfb_color_key color_key;
+
+    XVisualInfo vinfo;
+    XSetWindowAttributes xswa;
+    XWindowAttributes attribs;
+    unsigned long xswamask;
+    int depth;
+
+    Window root, parent;
+    Window *child;
+    unsigned int n_children;
+
+    fullscreen_flag = flags & VOFLAG_FULLSCREEN;
+    if (!fb_overlay_only)
+    {
+        if (!title)
+            title = "MPlayer OMAPFB (X11/FB) render";
+
+        XGetWindowAttributes(mDisplay, mRootWin, &attribs);
+        depth = attribs.depth;
+        if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
+            depth = 24;
+        XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, &vinfo);
+
+        xswa.border_pixel = 0;
+        xswa.background_pixel = xv_colorkey = TRANSPARENT_COLOR_KEY;
+
+        xswamask = CWBackPixel | CWBorderPixel;
+        xv_ck_info.method = CK_METHOD_BACKGROUND;
+
+        vo_x11_create_vo_window(&vinfo, vo_dx, vo_dy, vo_dwidth, vo_dheight,
+                                flags, CopyFromParent, "omapfb", title);
+        XChangeWindowAttributes(mDisplay, vo_window, xswamask, &xswa);
+
+        /* Need to receive events on the parent window -- so when it is
+           moved / resized / etc., we know. */
+        if(WinID > 0)
+        {
+            /* Query window tree information */
+            XQueryTree(mDisplay, vo_window, &root, &parent, &child, &n_children);
+            if (n_children)
+                XFree(child);
+
+            XUnmapWindow(mDisplay, vo_window);
+            if (parent)
+                XSelectInput(mDisplay, parent, StructureNotifyMask);
+            XMapWindow(mDisplay, vo_window);
+        }
+
+        vo_calc_drwXY(&drwX, &drwY);
+        vo_xv_draw_colorkey(drwX, drwY, vo_dwidth - 1, vo_dheight - 1);
+    }
+
+    fbmem = mmap(NULL, minfo.size, PROT_READ|PROT_WRITE, MAP_SHARED, dev_fd, 0);
+    if (fbmem == MAP_FAILED) {
+        mp_msg(MSGT_VO, MSGL_FATAL, "[omapfb] Error mmap\n");
+        return -1;
+    }
+
+    for (i = 0; i < minfo.size / 4; i++)
+        ((uint32_t*)fbmem)[i] = 0x80008000;
+
+    sinfo.xres = width & ~15;
+    sinfo.yres = height & ~15;
+    sinfo.xoffset = 0;
+    sinfo.yoffset = 0;
+    sinfo.nonstd = OMAPFB_COLOR_YUY422;
+
+    fb_pages[0].x = 0;
+    fb_pages[0].y = 0;
+    fb_pages[0].buf = fbmem;
+
+    if (dbl_buffer && minfo.size >= sinfo.xres * sinfo.yres * 2) {
+        sinfo.xres_virtual = sinfo.xres;
+        sinfo.yres_virtual = sinfo.yres * 2;
+        fb_pages[1].x = 0;
+        fb_pages[1].y = sinfo.yres;
+        fb_pages[1].buf = fbmem + sinfo.xres * sinfo.yres * 2;
+        fb_page_flip = 1;
+    } else {
+        sinfo.xres_virtual = sinfo.xres;
+        sinfo.yres_virtual = sinfo.yres;
+        fb_page_flip = 0;
+    }
+
+    ioctl(dev_fd, FBIOPUT_VSCREENINFO, &sinfo);
+    ioctl(dev_fd, FBIOGET_FSCREENINFO, &finfo);
+
+    if (WinID <= 0) {
+        if (fullscreen_flag) {
+            omapfb_update(0, 0, sinfo_p0.xres, sinfo_p0.yres, 1);
+        } else {
+            omapfb_update(sinfo_p0.xres / 2 - sinfo.xres / 2, sinfo_p0.yres / 2 - sinfo.yres / 2, sinfo.xres, sinfo.yres, 1);
+        }
+    }
+
+    color_key.channel_out = OMAPFB_CHANNEL_OUT_LCD;
+    color_key.background = 0x0;
+    color_key.trans_key = TRANSPARENT_COLOR_KEY;
+    if (fb_overlay_only)
+        color_key.key_type = OMAPFB_COLOR_KEY_DISABLED;
+    else
+        color_key.key_type = OMAPFB_COLOR_KEY_GFX_DST;
+    ioctl(dev_fd, OMAPFB_SET_COLOR_KEY, &color_key);
+
+    plane_ready = 1;
+    return 0;
+}
+
+static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+{
+    vo_draw_alpha_yuy2(w, h, src, srca, stride, fb_pages[page].buf + y0 * finfo.line_length + x0 * 2, finfo.line_length);
+}
+
+static void draw_osd(void)
+{
+    vo_draw_text(sinfo.xres, sinfo.yres, draw_alpha);
+}
+
+static int draw_frame(uint8_t *src[])
+{
+    return 1;
+}
+
+static int draw_slice(uint8_t *src[], int stride[], int w, int h, int x, int y)
+{
+    if (x!=0)
+        return 0;
+
+    if (!plane_ready)
+        return 0;
+
+    ioctl(dev_fd, OMAPFB_SYNC_GFX);
+
+    yuv420_to_yuv422(fb_pages[page].buf + y * finfo.line_length, src[0], src[1], src[2], w & ~15, h, stride[0], stride[1], finfo.line_length);
+    return 0;
+}
+
+static void flip_page(void)
+{
+    if (fb_page_flip) {
+        sinfo.xoffset = fb_pages[page].x + xoff;
+        sinfo.yoffset = fb_pages[page].y + yoff;
+        ioctl(dev_fd, FBIOPAN_DISPLAY, &sinfo);
+        page ^= fb_page_flip;
+    }
+}
+
+static int query_format(uint32_t format)
+{
+    // For simplicity pretend that we can only do YV12, support for
+    // other formats can be added quite easily if/when needed
+    if (format != IMGFMT_YV12)
+        return 0;
+
+    return VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW | VFCAP_OSD | VFCAP_SWSCALE | VFCAP_ACCEPT_STRIDE;
+}
+
+
+/**
+ * Uninitialize framebuffer
+ */
+static void uninit()
+{
+    pinfo.enabled = 0;
+    ioctl(dev_fd, OMAPFB_SETUP_PLANE, &pinfo);
+
+    if (!fb_overlay_only) {
+        struct omapfb_color_key color_key;
+        color_key.channel_out = OMAPFB_CHANNEL_OUT_LCD;
+        color_key.key_type = OMAPFB_COLOR_KEY_DISABLED;
+        ioctl(dev_fd, OMAPFB_SET_COLOR_KEY, &color_key);
+    }
+
+    close(dev_fd);
+
+    if (!fb_overlay_only)
+        x11_uninit();
+}
+
+
+static int control(uint32_t request, void *data)
+{
+    switch (request) {
+        case VOCTRL_QUERY_FORMAT:
+            return query_format(*((uint32_t*)data));
+        case VOCTRL_FULLSCREEN: {
+            if (WinID > 0) return VO_FALSE;
+            if (fullscreen_flag) {
+                if (!fb_overlay_only)
+                    vo_x11_fullscreen();
+                fullscreen_flag = 0;
+                omapfb_update(sinfo_p0.xres / 2 - sinfo.xres / 2, sinfo_p0.yres / 2 - sinfo.yres / 2, sinfo.xres, sinfo.yres, 1);
+            } else {
+                if (!fb_overlay_only)
+                    vo_x11_fullscreen();
+                fullscreen_flag = 1;
+                omapfb_update(0, 0, sinfo_p0.xres, sinfo_p0.yres, 1);
+            }
+            return VO_TRUE;
+        }
+        case VOCTRL_UPDATE_SCREENINFO:
+            update_xinerama_info();
+            return VO_TRUE;
+    }
+    return VO_NOTIMPL;
+}
+
+
+static void check_events(void)
+{
+    if (!fb_overlay_only)
+        x11_check_events();
+}
diff --git a/libvo/yuv.S b/libvo/yuv.S
new file mode 100644
index 0000000..1cd2c1d
--- /dev/null
+++ b/libvo/yuv.S
@@ -0,0 +1,170 @@
+/*
+    Copyright (C) 2008 Mans Rullgard
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation
+    files (the "Software"), to deal in the Software without
+    restriction, including without limitation the rights to use, copy,
+    modify, merge, publish, distribute, sublicense, and/or sell copies
+    of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+ */
+
+        .macro mov32    rd, val
+        movw            \rd, #:lower16:\val
+        movt            \rd, #:upper16:\val
+        .endm
+
+        .fpu neon
+        .text
+
+@ yuv420_to_yuv422(uint8_t *yuv, uint8_t *y, uint8_t *u, uint8_t *v,
+@                  int w, int h, int yw, int cw, int dw)
+
+#define yuv  r0
+#define y    r1
+#define u    r2
+#define v    r3
+#define w    r4
+#define h    r5
+#define yw   r6
+#define cw   r7
+#define dw   r8
+
+#define tyuv r9
+#define ty   r10
+#define tu   r11
+#define tv   r12
+#define i    lr
+
+        .global yuv420_to_yuv422
+        .func   yuv420_to_yuv422
+yuv420_to_yuv422:
+        push            {r4-r11,lr}
+        add             r4,  sp,  #36
+.Ldo_conv:
+        ldm             r4, {r4-r8}
+        push            {r4}
+1:
+        mov             tu,   u
+        mov             tv,   v
+        vld1.64         {d2}, [u,:64], cw               @ u0
+        vld1.64         {d3}, [v,:64], cw               @ v0
+        mov             tyuv, yuv
+        mov             ty,   y
+        vzip.8          d2,   d3                        @ u0v0
+        mov             i,    #16
+2:                      
+        pld             [y, #64]
+        vld1.64         {d0, d1},   [y,:128], yw        @ y0
+        pld             [u, #64]
+        subs            i,    i,    #4
+        vld1.64         {d6},       [u,:64],  cw        @ u2
+        pld             [y, #64]
+        vld1.64         {d4, d5},   [y,:128], yw        @ y1
+        pld             [v, #64]
+        vld1.64         {d7},       [v,:64],  cw        @ v2
+        pld             [y, #64]
+        vld1.64         {d16,d17},  [y,:128], yw        @ y2
+        vzip.8          d6,   d7                        @ u2v2
+        pld             [u, #64]
+        vld1.64         {d22},      [u,:64],  cw        @ u4
+        pld             [v, #64]
+        vld1.64         {d23},      [v,:64],  cw        @ v4
+        pld             [y, #64]
+        vld1.64         {d20,d21},  [y,:128], yw        @ y3
+        vmov            q9,   q3                        @ u2v2
+        vzip.8          d22,  d23                       @ u4v4
+        vrhadd.u8       q3,   q1,   q3                  @ u1v1
+        vzip.8          q0,   q1                        @ y0u0y0v0
+        vmov            q12,  q11                       @ u4v4
+        vzip.8          q2,   q3                        @ y1u1y1v1
+        vrhadd.u8       q11,  q9,   q11                 @ u3v3
+        vst1.64         {d0-d3},    [yuv,:128], dw      @ y0u0y0v0
+        vzip.8          q8,   q9                        @ y2u2y2v2
+        vst1.64         {d4-d7},    [yuv,:128], dw      @ y1u1y1v1
+        vzip.8          q10,  q11                       @ y3u3y3v3
+        vst1.64         {d16-d19},  [yuv,:128], dw      @ y2u2y2v2
+        vmov            q1,   q12
+        vst1.64         {d20-d23},  [yuv,:128], dw      @ y3u3y3v3
+        bgt             2b
+
+        subs            w,    w,    #16
+        add             yuv,  tyuv, #32
+        add             y,    ty,   #16
+        add             u,    tu,   #8
+        add             v,    tv,   #8
+        bgt             1b
+
+        ldr             w,    [sp]
+        subs            h,    h,    #16
+        add             yuv,  yuv,  dw, lsl #4
+        sub             yuv,  yuv,  w,  lsl #1
+        add             y,    y,    yw, lsl #4
+        sub             y,    y,    w
+        add             u,    u,    cw, lsl #3
+        sub             u,    u,    w,  asr #1
+        add             v,    v,    cw, lsl #3
+        sub             v,    v,    w,  asr #1
+        bgt             1b
+
+        pop             {r3-r11,pc}
+        .endfunc
+
+        .func   neon_open
+neon_open:
+        push            {r4-r8,lr}
+        ldrd            r4,  r5,  [r0, #16]
+        ldrd            r6,  r7,  [r0, #24]
+        lsl             r8,  r4,  #1
+        mov32           r0,  conv_params
+        stm             r0,  {r4-r8}
+        mov             r0,  #0
+        pop             {r4-r8,pc}
+        .endfunc
+
+        .func   neon_convert
+neon_convert:
+        push            {r4-r11,lr}
+        ldr             r0,  [r0]
+        mov32           r4,  conv_params
+        ldm             r1,  {r1-r3}
+        b               .Ldo_conv
+        .endfunc
+
+        .func   neon_nop
+neon_nop:
+        bx              lr
+        .endfunc
+
+        .section .bss
+conv_params:
+        .skip           5*4
+        .size           conv_params, . - conv_params
+
+        .section        .rodata
+.Lname: .asciz          "neon"
+ofb_pixconv_neon:
+        .word           .Lname
+        .word           0               @ flags
+        .word           neon_open
+        .word           neon_convert
+        .word           neon_nop        @ finish
+        .word           neon_nop        @ close
+        .size           ofb_pixconv_neon, . - ofb_pixconv_neon
+
+        .section        .ofb_pixconv, "a"
+ofb_pixconv_neon_p:
+        .word           ofb_pixconv_neon
-- 
1.7.7.1

