#!/usr/bin/env python

import sys, os, getopt, glob, copy
sys.path.append('/usr/share/oe')
import oe
from oe import *

try:
    import itertools
except ImportError: # itertools appears in Python 2.3
    from utils import itertools
try:
    import optparse
except ImportError: # optparse appears in Python 2.3
    from utils import optparse
parsespin = itertools.cycle( r'|/-\-' )

__version__ = 1.1
usageinfo = """%prog [options] [package ...]

Builds specified packages, expecting that the .oe files
it has to work from are in OEFILES
Default packages are all packages in OEFILES.
Default OEFILES are the .oe files in the current directory."""

def usage( ):
    sys.__stderr__.write(usageinfo.replace('%prog', 'oemake') + "\n")
    sys.exit(0)

def handle_options( args ):
    parser = optparse.OptionParser( version = "OpenEmbedded Build Infrastructure Core version %s, %%prog version %s" % ( oe.__version__, __version__ ), usage = usageinfo )

    parser.add_option( "-k", "--continue", help = "continue as much as possible after an error. While the target that failed, and those that depend on it, cannot be remade, the other dependencies of these targets can be processed all the same.",
            action = "store_false", dest = "abort", default = True )

    parser.add_option( "-f", "--force", help = "force run of specified cmd, regardless of stamp status",
            action = "store_true", dest = "force", default = False )


    parser.add_option( "-c", "--cmd", help = "specify command to pass to oebuild",
            action = "store", dest = "cmd", default = "build" )

    options, args = parser.parse_args( args )
    return options, args[1:]

def myProgressCallback( x, y, f ):
    sys.stdout.write("\rNOTE: Parsing .oe files: %s (%04d/%04d) [%2d %%]" % ( parsespin.next(), x, y, x*100/y ) )
    sys.stdout.flush()

#
# main
#

if __name__ == "__main__":

    make.options, args = handle_options( sys.argv )

    _depcmds = { "clean": None,
        "mrproper": None,
        "build": "stage" }

    if not make.options.cmd:
        make.options.cmd = "build"

    if make.options.cmd in _depcmds:
        depcmd=_depcmds[make.options.cmd]
    else:
        depcmd=make.options.cmd

    make.pkgdata = {}
    make.pkgs = {}
    make.cfg = {}
    make.graph = digraph()

    try:
        make.cfg = parse.handle("conf/oe.conf", make.cfg)
    except IOError:
        fatal("Unable to open oe.conf")

    if not data.getVar("BUILDNAME", make.cfg):
        data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), make.cfg)

    buildname = data.getVar("BUILDNAME", make.cfg)

    try:
        make.collect_oefiles( myProgressCallback )
        sys.stdout.write("\n")
        make.build_depgraph( depcmd )

        event.fire(event.BuildStarted(buildname, make.graph.okeys, make.cfg))

        pkgs_to_build = None
        if args:
            if not pkgs_to_build:
                pkgs_to_build = []
            pkgs_to_build.extend(args)
        if not pkgs_to_build:
            oepkgs = data.getVar('OEPKGS', make.cfg, 1)
            if oepkgs:
                pkgs_to_build = string.split(oepkgs)
        if not pkgs_to_build:
            pkgs_to_build = make.graph.okeys
        debug(1, "building: %s" % pkgs_to_build)

        for k in pkgs_to_build:
            if k in make.pkgs:
                ret = make.graph.walkdown(k, make.buildPackage)
                if make.options.abort and not ret:
                    fatal("Build of %s failed, aborting." % k)
            else:
                error("Unable to build %s: no .oe file provides it." % k)
                if make.options.abort:
                    sys.exit(1)

        event.fire(event.BuildCompleted(buildname, make.graph.okeys, make.cfg))

    except KeyboardInterrupt:
        print "\nNOTE: KeyboardInterrupt - Build not completed."
