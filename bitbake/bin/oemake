#!/usr/bin/python

import string, sys, os
from oe import *

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	pkg = property(getPkg, setPkg, None, "pkg property")

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	data = property(getData, setData, None, "data property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")
	
class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build succeeded"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

def getParents(graph, item):
	if not graph.hasnode(item):
		return None
	return graph.dict[item][1]

def getChildren(graph, item):
	if not graph.hasnode(item):
		return None
	children = []
	for i in graph.okeys:
		if item in getParents(graph, i):
			children.append(i)
	return children

def followdown(graph, item, callback):
	if not graph.hasnode(item):
		return 0
	keycount = graph.dict[item][0]
	if keycount != 0 and depcmd is not None:
		command=depcmd
	else:
		command=cmd
	parents = getParents(graph, item)
	if parents is not None:
		for p in parents:
			ret = followdown(graph, p, callback)
			if ret == 0:
				return 0
	return callback(item, command)

def followup(graph, item, callback):
	if not graph.hasnode(item):
		return 0
	children = getChildren(graph, item)
	if children is not None:
		for c in children:
			ret = followup(graph, c, callback)
			if ret == 0:
				return 0
	return callback(graph, item)

# Then, start the build for that package.  Note that because
# we've already loaded the files, we may as well spawn the build
# directly.. so lets abstract the task handling bits into a
# module that both oebuild and oemake can utilize.

__build_cache_fail = []
__build_cache = []
def build(item, command):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
#	note("oebuild %s %s" % (command, fn))
	event.fire(PkgStarted(item, pkgdata[fn]))
	ret = os.system("oebuild %s %s" % (command, fn))
	if ret == 0:
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		return 1
	else:
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0
	
_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

parse.init(".conf", cfg)
data.setVarFlag("OEFILES", "inherit", "1", cfg)
data.setVarFlag("OEDIR", "inherit", "1", cfg)
data.setVarFlag("OEPATH", "inherit", "1", cfg)
data.setVarFlag("PATH", "inherit", "1", cfg)
data.inheritFromOS(1, cfg)

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

oefiles = data.getVar("OEFILES", cfg)
if oefiles is not None:
	files = oefiles.split()
else:
	fatal("OEFILES not defined")

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

#pkg = [ "pkgname", "depends", "provides" ]

for f in files:
	# read a file's metadata
	try:
		from copy import copy
		pkgdata[f] = parse.handle(f, copy(cfg))
		deps = None
		if pkgdata[f] is not None:
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f])
			if depstr is not None:
				deps = depstr.split()
			pkg = catpkgsplit(f)
			if pkg == None:
				continue
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			provides.append("%s/%s-%s" % (pkg[0], pkg[1], pkg[2]))
			provides.append("%s/%s" % (pkg[0], pkg[1]))
			providestr = data.getVar("PROVIDES", pkgdata[f])
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if deps is not None:
		for d in deps:
			if not graph.hasnode(d):
				def killitem(graph, item):
					global __tokill
					__tokill.append(item)
				followup(graph, pkg, killitem)
				__unsatisfied.append([pkg, d])
				break
			graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	followup(graph, k, reallykillitem)

for k in graph.okeys:
	followdown(graph, k, build)
