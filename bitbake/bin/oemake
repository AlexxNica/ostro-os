#!/usr/bin/env python

import sys, os, getopt, glob, copy
sys.path.append('/usr/share/oe')
import oe
from oe import *

try:
    import itertools
except ImportError: # itertools appears in Python 2.3
    from utils import itertools
try:
    import optparse
except ImportError: # optparse appears in Python 2.3
    from utils import optparse
parsespin = itertools.cycle( r'|/-\-' )

__build_cache_fail = []
__build_cache = []

__version__ = 1.1
usageinfo = """%prog [options] [package ...]

Builds specified packages, expecting that the .oe files
it has to work from are in OEFILES
Default packages are all packages in OEFILES.
Default OEFILES are the .oe files in the current directory."""

def usage( ):
    sys.__stderr__.write(usageinfo.replace('%prog', 'oemake') + "\n")
    sys.exit(0)

def handle_options( args ):
    parser = optparse.OptionParser( version = "OpenEmbedded Build Infrastructure Core version %s, %%prog version %s" % ( oe.__version__, __version__ ), usage = usageinfo )

    parser.add_option( "-k", "--continue", help = "continue as much as possible after an error. While the target that failed, and those that depend on it, cannot be remade, the other dependencies of these targets can be processed all the same.",
            action = "store_false", dest = "abort", default = True )

    parser.add_option( "-f", "--force", help = "force run of specified cmd, regardless of stamp status",
            action = "store_true", dest = "force", default = False )


    parser.add_option( "-c", "--cmd", help = "specify command to pass to oebuild",
            action = "store", dest = "cmd", default = "build" )

    options, args = parser.parse_args( args )
    return options, args[1:]

graph = digraph()

def buildPackage(graph, item):
    if item in __build_cache:
        return 1
    if item in __build_cache_fail:
        return 0
    fn = pkgs[item][1]
    if fn is None:
        return 1
    command = make.options.cmd
    debug(1, "oebuild %s %s" % (command, fn))
    event.fire(event.PkgStarted(item, make.pkgdata[fn]))
    try:
        oe.build.exec_task('do_%s' % command, make.pkgdata[fn])
        event.fire(event.PkgSucceeded(item, make.pkgdata[fn]))
        __build_cache.append(item)
        del make.pkgdata[fn]
        return 1
    except oe.build.FuncFailed:
        error("task stack execution failed")
        event.fire(event.PkgFailed(item, make.pkgdata[fn]))
        __build_cache_fail.append(item)
        del make.pkgdata[fn]
        return 0
    except oe.build.EventException:
        (type, value, traceback) = sys.exc_info()
        e = value.event
        error("%s event exception, aborting" % event.getName(e))
        event.fire(event.PkgFailed(item, make.pkgdata[fn]))
        __build_cache_fail.append(item)
        del make.pkgdata[fn]
        return 0

def build_depgraph( depcmd ):
    for f in make.pkgdata.keys():
        depstr = data.getVar("DEPENDS", make.pkgdata[f], 1)
        if depstr is not None:
            deps = depstr.split()
        pkg = []
        pkg.append(data.getVar('CATEGORY', make.pkgdata[f], 1))
        pkg.append(data.getVar('PN', make.pkgdata[f], 1))
        pkg.append(data.getVar('PV', make.pkgdata[f], 1))
        pkg.append(data.getVar('PR', make.pkgdata[f], 1))
        root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
        provides = []
        providestr = data.getVar("PROVIDES", make.pkgdata[f], 1)
        if providestr is not None:
            provides += providestr.split()
        for provide in provides:
            pkgs[provide] = [[root], None]
        pkgs[root] = [deps, f]
    
    # add every provide relationship to the dependency graph, depending
    # on all the packages that provide it

    tokill = []
    unsatisfied = []

    for pkg in pkgs.keys():
        graph.addnode(pkg, None)

    for pkg in pkgs.keys():
        (deps, fn) = pkgs[pkg]
        if depcmd is not None:
            if deps is not None:
                for d in deps:
                    if not graph.hasnode(d):
                        def killitem(graph, item):
                            tokill.append(item)
                        graph.walkup(pkg, killitem)
                        unsatisfied.append([pkg, d])
                        break
                    graph.addnode(pkg, d)

    for u in unsatisfied:
        event.fire(event.UnsatisfiedDep(u[0], make.pkgdata[pkgs[u[0]][1]], u[1]))

    for k in tokill:
        def reallykillitem(graph, item):
            graph.delnode(item)
        graph.walkup(k, reallykillitem)

def myProgressCallback( x, y, f ):
    sys.stdout.write("\rNOTE: Parsing .oe files: %s (%04d/%04d) [%2d %%]" % ( parsespin.next(), x, y, x*100/y ) )
    sys.stdout.flush()

#
# main
#

if __name__ == "__main__":

    make.options, args = handle_options( sys.argv )

    _depcmds = { "clean": None,
        "mrproper": None,
        "build": "stage" }

    if not make.options.cmd:
        make.options.cmd = "build"

    if make.options.cmd in _depcmds:
        depcmd=_depcmds[make.options.cmd]
    else:
        depcmd=make.options.cmd

    make.pkgdata = {}
    make.cfg = {}
    graph = digraph()
    pkgs = {}

    try:
        make.cfg = parse.handle("conf/oe.conf", make.cfg)
    except IOError:
        fatal("Unable to open oe.conf")
    except Exception, e:
	fatal("%s" % e)

    if not data.getVar("BUILDNAME", make.cfg):
        data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), make.cfg)

    buildname = data.getVar("BUILDNAME", make.cfg)

    try:
        make.collect_oefiles( myProgressCallback )
        sys.stdout.write("\n")
        build_depgraph( depcmd )

        event.fire(event.BuildStarted(buildname, graph.okeys, make.cfg))

        pkgs_to_build = None
        if args:
            if not pkgs_to_build:
                pkgs_to_build = []
            pkgs_to_build.extend(args)
        if not pkgs_to_build:
            oepkgs = data.getVar('OEPKGS', make.cfg, 1)
            if oepkgs:
                pkgs_to_build = oepkgs.split()
        if not pkgs_to_build:
            pkgs_to_build = graph.okeys
        debug(1, "building: %s" % pkgs_to_build)

        for k in pkgs_to_build:
            if k in pkgs:
                ret = graph.walkdown(k, buildPackage, usecache=True)
                if make.options.abort and not ret:
                    fatal("Build of %s failed, aborting." % k)
            else:
                error("Unable to build %s: no .oe file provides it." % k)
                if make.options.abort:
                    sys.exit(1)

        event.fire(event.BuildCompleted(buildname, graph.okeys, make.cfg))

    except KeyboardInterrupt:
        print "\nNOTE: KeyboardInterrupt - Build not completed."
