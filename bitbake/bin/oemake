#!/usr/bin/python

import string, sys, os
from oe import *

class PkgFailed(event.Event):
	"""Package build failed"""
	type = "PkgFailed"

class PkgSucceeded(event.Event):
	"""Package build succeeded"""
	type = "PkgSucceeded"

def getParents(graph, item):
	if not graph.hasnode(item):
		return None
	return graph.dict[item][1]

def addToBuild(data, graph, item):
	if not graph.hasnode(item):
		return 0
	keycount = graph.dict[item][0]
	if keycount != 0 and depcmd is not None:
		command=depcmd
	else:
		command=cmd
	parents = getParents(graph, item)
	if parents is not None:
		for p in parents:
			addToBuild(data, graph, p)
	if not [item, command] in data:
		data.append([item, command])
	return 1

_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

parse.init(".conf", cfg)
data.setVarFlag("OEFILES", "inherit", "1", cfg)
data.setVarFlag("OEDIR", "inherit", "1", cfg)
data.setVarFlag("OEPATH", "inherit", "1", cfg)
data.setVarFlag("PATH", "inherit", "1", cfg)
data.inheritFromOS(1, cfg)

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

oefiles = data.getVar("OEFILES", cfg)
if oefiles is not None:
	files = oefiles.split()
else:
	fatal("OEFILES not defined")

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

#pkg = [ "pkgname", "depends", "provides" ]

for f in files:
	# read a file's metadata
	(root, ext) = os.path.splitext(f)
	try:
		from copy import copy
		pkgdata[f] = parse.handle(f, copy(cfg))
		deps = None
		if pkgdata[f] is not None:
			depstr = data.getVar("DEPENDS", pkgdata[f])
			if depstr is not None:
				deps = depstr.split()
			provides = data.getVar("PROVIDES", pkgdata[f])
			if provides is not None:
				provides = provides.split()
				for provide in provides:
					pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
#		if pkgdata[f] is not None:
#			data.emit_env(sys.__stdout__, pkgdata[f])
	except IOError:
		print "error opening %s" % f
		pass

# default provides.. a package provides itself, with and without
# version and revision

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

for pkg in pkgs.keys():
#	print "graph.addnode(%s, %s)" % (pkg, None)
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if deps is not None:
		for d in deps:
#			print "graph.addnode(%s, %s)" % (pkg, d)
			graph.addnode(pkg, d)
	
# Then, start the build for that package.  Note that because
# we've already loaded the files, we may as well spawn the build
# directly.. so lets abstract the task handling bits into a
# module that both oebuild and oemake can utilize.

data = []
for k in graph.okeys:
	addToBuild(data, graph, k)

for d in data:
	(pkg, step) = d 
	if pkgs[pkg][1] is not None:
		note("oebuild %s %s" % (step, pkgs[pkg][1]))
		os.system("oebuild %s %s" % (step, pkgs[pkg][1]))
