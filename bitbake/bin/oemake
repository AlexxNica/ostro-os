#!/usr/bin/env python

import string, sys, os, getopt, glob, copy
sys.path.append('/usr/share/oe')
import oe
from oe import *
try:
    import itertools
except ImportError: # itertools appears in Python 2.3
    from utils import itertools
try:
    import optparse
except ImportError: # optparse appears in Python 2.3
    from utils import optparse

__version__ = 1.1

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	pkg = property(getPkg, setPkg, None, "pkg property")
	data = property(getData, setData, None, "data property")

class BuildBase(event.Event):
	"""Base class for oemake run events"""

	def __init__(self, n, p, c):
		self.name = n
		self.pkgs = p
		self.cfg = c

	def getPkgs(self):
		return self._pkgs

	def setPkgs(self, pkgs):
		self._pkgs = pkgs

	def getName(self):
		return self._name

	def setName(self, name):
		self._name = name

	def getCfg(self):
		return self._cfg

	def setCfg(self, cfg):
		self._cfg = cfg

	pkgs = property(getPkgs, setPkgs, None, "pkgs property")
	name = property(getName, setName, None, "name property")
	cfg = property(getCfg, setCfg, None, "cfg property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")

class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build completed"""

class BuildStarted(BuildBase):
	"""oemake build run started"""

class BuildCompleted(BuildBase):
	"""oemake build run completed"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

__build_cache_fail = []
__build_cache = []

def build(graph, item):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
	command = options.cmd
	debug(1, "oebuild %s %s" % (command, fn))
	event.fire(PkgStarted(item, pkgdata[fn]))
	try:
		oe.build.exec_task('do_%s' % command, pkgdata[fn])
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		del pkgdata[fn]
		return 1
	except oe.build.FuncFailed:
		error("task stack execution failed")
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		del pkgdata[fn]
		return 0
	except oe.build.EventException:
		(type, value, traceback) = sys.exc_info()
		e = value.event
		error("%s event exception, aborting" % event.getName(e))
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		del pkgdata[fn]
		return 0

def get_oefiles():
	"""Get default oefiles"""
	dirs = os.listdir(os.getcwd())
	oefiles = []
	for f in dirs:
		(root, ext) = os.path.splitext(f)
		if ext == ".oe":
			oefiles.append(os.path.abspath(os.path.join(os.getcwd(),f)))
	return oefiles

def load_oefile(oefile, cfgdata):
	oepath = data.getVar('OEPATH', cfg)
	topdir = data.getVar('TOPDIR', cfg)
	if not topdir:
		topdir = os.path.abspath(os.getcwd())
		# set topdir to here
		data.setVar('TOPDIR', topdir, cfg)
	oefile = os.path.abspath(oefile)
	oefile_loc = os.path.abspath(os.path.dirname(oefile))
	# expand tmpdir to include this topdir
	data.setVar('TMPDIR', data.getVar('TMPDIR', cfg, 1) or "", cfg)
	# add topdir to oepath
	oepath += ":%s" % topdir
	# set topdir to location of .oe file
	topdir = oefile_loc
	#data.setVar('TOPDIR', topdir, cfg)
	# add that topdir to oepath
	oepath += ":%s" % topdir
	# go there
	oldpath = os.path.abspath(os.getcwd())
	os.chdir(topdir)
	data.setVar('OEPATH', oepath, cfg)
	oe = copy.deepcopy(cfgdata)
	try:
		parse.handle(oefile, oe) # read .oe data
		os.chdir(oldpath)
		return oe
	except IOError, OSError:
		os.chdir(oldpath)
		return None


def handle_options( args ):
        parser = optparse.OptionParser( version = "OpenEmbedded Build Infrastructure Core version %s, %%prog version %s" % ( oe.__version__, __version__ ),
        usage = """%prog [options] [package ...]

Builds specified packages, expecting that the .oe files
it has to work from are in OEFILES
Default packages are all packages in OEFILES.
Default OEFILES are the .oe files in the current directory.""" )

        parser.add_option( "-k", "--continue", help = "continue as much as possible after an error. While the target that failed, and those that depend on it, cannot be remade, the other dependencies of these targets can be processed all the same.",
                           action = "store_false", dest = "abort", default = True )

        parser.add_option( "-f", "--force", help = "force run of specified cmd, regardless of stamp status",
                           action = "store_true", dest = "force", default = False )


        parser.add_option( "-c", "--cmd", help = "specify command to pass to oebuild",
                           action = "store", dest = "cmd", default = "build" )

        options, args = parser.parse_args( args )
        return options, args[1:]

#
# main
#

options, args = handle_options( sys.argv )

_depcmds = { "clean": None,
	     "mrproper": None,
	     "build": "stage" }

if not options.cmd:
	options.cmd = "build"

if options.cmd in _depcmds:
	depcmd=_depcmds[options.cmd]
else:
	depcmd=options.cmd

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

try:
	cfg = parse.handle("conf/oe.conf", cfg)
except IOError:
	fatal("Unable to open oe.conf")

if not data.getVar("BUILDNAME", cfg):
	data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), cfg)

buildname = data.getVar("BUILDNAME", cfg)



#
# grab oefiles
#

files = string.split(data.getVar("OEFILES", cfg, 1) or "")
data.setVar("OEFILES", string.join(files), cfg)

if not len(files):
	files = get_oefiles()

if not len(files):
	usage()

parsespin = itertools.cycle( r'|/-\-' )
sys.stdout.write("NOTE: Parsing .oe files: %s" % parsespin.next())

for f in files:
	globbed = glob.glob(f) or [ f ]
	if globbed:
		if [ f ] != globbed:
			files += globbed
			continue
	# read a file's metadata
	try:
		debug(1, "oemake: parsing %s" % f)
		sys.stdout.write("\b \b%s" % parsespin.next())
		sys.stdout.flush()
		pkgdata[f] = load_oefile(f, cfg)
		deps = None
		if pkgdata[f] is not None:
			# allow metadata files to add items to OEFILES
			#data.update_data(pkgdata[f])
			addoefiles = data.getVar('OEFILES', pkgdata[f]) or None
			if addoefiles:
				for aof in string.split(addoefiles):
					if not files.count(aof):
						if not os.path.isabs(aof):
							aof = os.path.join(os.path.dirname(f),aof)
						files.append(aof)
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f], 1)
			if depstr is not None:
				deps = depstr.split()
			pkg = []
			pkg.append(data.getVar('CATEGORY', pkgdata[f], 1))
			pkg.append(data.getVar('PN', pkgdata[f], 1))
			pkg.append(data.getVar('PV', pkgdata[f], 1))
			pkg.append(data.getVar('PR', pkgdata[f], 1))
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			providestr = data.getVar("PROVIDES", pkgdata[f], 1)
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

sys.stdout.write("\n")

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if depcmd is not None:
		if deps is not None:
			for d in deps:
				if not graph.hasnode(d):
					def killitem(graph, item):
						global __tokill
						__tokill.append(item)
					graph.walkup(pkg, killitem)
					__unsatisfied.append([pkg, d])
					break
				graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	graph.walkup(k, reallykillitem)

event.fire(BuildStarted(buildname, graph.okeys, cfg))

pkgs_to_build = None
if args:
	if not pkgs_to_build:
		pkgs_to_build = []
	pkgs_to_build.extend(args)
if not pkgs_to_build:
	oepkgs = data.getVar('OEPKGS', cfg, 1)
	if oepkgs:
		pkgs_to_build = string.split(oepkgs)
if not pkgs_to_build:
	pkgs_to_build = graph.okeys
debug(1, "building: %s" % pkgs_to_build)

for k in pkgs_to_build:
	if k in pkgs:
		ret = graph.walkdown(k, build)
		if options.abort and not ret:
			fatal("Build of %s failed, aborting." % k)
	else:
		error("Unable to build %s: no .oe file provides it." % k)
		if options.abort:
			sys.exit(1)

event.fire(BuildCompleted(buildname, graph.okeys, cfg))
