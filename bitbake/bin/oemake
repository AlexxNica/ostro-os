#!/usr/bin/python

import string, sys, os
sys.path.append('/usr/share/oe')
from oe import *
import oe

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	pkg = property(getPkg, setPkg, None, "pkg property")

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	data = property(getData, setData, None, "data property")

class BuildBase(event.Event):
	"""Base class for oemake run events"""

	def __init__(self, n, p, c):
		self.name = n
		self.pkgs = p
		self.cfg = c

	def getPkgs(self):
		return self._pkgs

	def setPkgs(self, pkgs):
		self._pkgs = pkgs

	pkgs = property(getPkgs, setPkgs, None, "pkgs property")

	def getName(self):
		return self._name

	def setName(self, name):
		self._name = name

	name = property(getName, setName, None, "name property")

	def getCfg(self):
		return self._cfg

	def setCfg(self, cfg):
		self._cfg = cfg

	cfg = property(getCfg, setCfg, None, "cfg property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")
	
class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build succeeded"""

class BuildStarted(BuildBase):
	"""oemake build run started"""

class BuildCompleted(BuildBase):
	"""oemake build run completed"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

__build_cache_fail = []
__build_cache = []
def build(graph, item):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
	command = cmd
	debug(1, "oebuild %s %s" % (command, fn))
	event.fire(PkgStarted(item, pkgdata[fn]))
	opts = ""
	if force:
		opts += " --force"
	ret = os.system("oebuild %s %s %s" % (opts, command, fn))
	if ret == 0:
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		return 1
	else:
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0

def usage():
	print "Usage: oemake [options] [package ...]"
	print ""
	print "Builds specified packages, expecting that the .oe files"
	print "it has to work from are in OEFILES"
	print "Default packages are all packages in OEFILES."
	print "Default OEFILES are the .oe files in the current directory."
	print "Example: oemake glibc"
	print "Example: oemake ncurses-5.3"
	print ""
	print "  %s\t\t%s" % ("-v, --version", "output version information and exit")
	print "  %s\t\t%s" % ("-c [arg], --cmd [arg]", "specify command to pass to oebuild")
	print "  %s\t\t%s" % ("-a, --abort", "abort build if any package build fails")
	print "  %s\t\t%s" % ("-f, --force", "force run of specified cmd, regardless of status")
	sys.exit(0)

__version__ = 1.1
def version():
	print "OpenEmbedded Build Infrastructure Core version %s" % oe.__version__
	print "OEMake version %s" % __version__

def get_oefiles():
	"""Get default oefiles"""
	dirs = os.listdir(os.getcwd())
	oefiles = []
	for f in dirs:
		(root, ext) = os.path.splitext(f)
		if ext == ".oe":
			oefiles.append(os.path.abspath(os.path.join(os.getcwd(),f)))
	return oefiles

def get_oefile():
	"""Get default oefile"""
	oefiles = get_oefiles()
	if len(oefiles):
		return oefiles[0]
	else:
		return None

import getopt
try:
	(opts, args) = getopt.getopt(sys.argv[1:], 'vc:fa', [ 'version', 'cmd=', 'abort', 'force' ])
except getopt.GetoptError:
	usage()

# handle opts
optsonly = [ opt for (opt,val) in opts]
cmd = None

def getopthash(l):
	h = {}
	for (opt, val) in l:
		h[opt] = val
	return h

opthash = getopthash(opts)

if opthash.has_key('--version') or opthash.has_key('-v'):
	version()
	sys.exit(0)

if opthash.has_key('--abort') or opthash.has_key('-a'):
	abort = 1
else:
	abort = 0

if opthash.has_key('--force') or opthash.has_key('-f'):
	force = 1
else:
	force = 0

if opthash.has_key('--cmd'):
	cmd = opthash['--cmd']
if opthash.has_key('-c'):
	cmd = opthash['-c']

_depcmds = { "clean": None,
	     "mrproper": None,
	     "build": "stage",
	     "install": None, }

if not cmd:
	cmd = "build"

if _depcmds.has_key(cmd):
	depcmd=_depcmds[cmd]
else:
	depcmd=cmd

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

if not data.getVar("BUILDNAME", cfg):
	data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), cfg)

buildname = data.getVar("BUILDNAME", cfg)

# grab oefiles
files = string.split(data.getVar("OEFILES", cfg, 1) or "")
data.setVar("OEFILES", string.join(files), cfg)

if not len(files):
	files = get_oefiles()

if not len(files):
	usage()

import glob
for f in files:
	globbed = glob.glob(f) or [ f ]
	if globbed:
		if [ f ] != globbed:
			files += globbed
			continue
	# read a file's metadata
	try:
		from copy import deepcopy
		pkgdata[f] = parse.handle(f, deepcopy(cfg))
		deps = None
		if pkgdata[f] is not None:
			# allow metadata files to add items to OEFILES
			data.update_data(pkgdata[f])
			addoefiles = data.getVar('OEFILES', pkgdata[f]) or None
			if addoefiles:
				for aof in string.split(addoefiles):
					if not files.count(aof):
						if not os.path.isabs(aof):
							aof = os.path.join(os.path.dirname(f),aof)
						files.append(aof)
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f], 1)
			if depstr is not None:
				deps = depstr.split()
			pkg = []
			pkg.append(data.getVar('CATEGORY', pkgdata[f], 1))
			pkg.append(data.getVar('PN', pkgdata[f], 1))
			pkg.append(data.getVar('PV', pkgdata[f], 1))
			pkg.append(data.getVar('PR', pkgdata[f], 1))
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			# w/ category
			provides.append("%s/%s-%s" % (pkg[0], pkg[1], pkg[2]))
			provides.append("%s/%s" % (pkg[0], pkg[1]))
			# w/o category
			provides.append("%s" % pkg[1])
			provides.append("%s-%s" % (pkg[1], pkg[2]))
			provides.append("%s-%s-%s" % (pkg[1], pkg[2], pkg[3]))
			providestr = data.getVar("PROVIDES", pkgdata[f], 1)
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if _depcmds.has_key(cmd) and _depcmds[cmd] is not None:
		if deps is not None:
			for d in deps:
				if not graph.hasnode(d):
					def killitem(graph, item):
						global __tokill
						__tokill.append(item)
					graph.walkup(pkg, killitem)
					__unsatisfied.append([pkg, d])
					break
				graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	graph.walkup(k, reallykillitem)

event.fire(BuildStarted(buildname, graph.okeys, cfg))
packages = args or graph.okeys

for k in packages:
	if pkgs.has_key(k):
		ret = graph.walkdown(k, build)
		if abort and not ret:
			oe.fatal("Build of %s failed, aborting." % k)
	else:
		oe.error("Unable to build %s: no .oe file provides it." % k)
		if abort:
			sys.exit(1)

event.fire(BuildCompleted(buildname, graph.okeys, cfg))
