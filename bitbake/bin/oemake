#!/usr/bin/env python

import string, sys, os, getopt, glob, copy
sys.path.append('/usr/share/oe')
from oe import *
import oe

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	pkg = property(getPkg, setPkg, None, "pkg property")
	data = property(getData, setData, None, "data property")

class BuildBase(event.Event):
	"""Base class for oemake run events"""

	def __init__(self, n, p, c):
		self.name = n
		self.pkgs = p
		self.cfg = c

	def getPkgs(self):
		return self._pkgs

	def setPkgs(self, pkgs):
		self._pkgs = pkgs

	def getName(self):
		return self._name

	def setName(self, name):
		self._name = name

	def getCfg(self):
		return self._cfg

	def setCfg(self, cfg):
		self._cfg = cfg

	pkgs = property(getPkgs, setPkgs, None, "pkgs property")
	name = property(getName, setName, None, "name property")
	cfg = property(getCfg, setCfg, None, "cfg property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")
	
class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build completed"""

class BuildStarted(BuildBase):
	"""oemake build run started"""

class BuildCompleted(BuildBase):
	"""oemake build run completed"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

class Spinner:
    """Text spinner originally from:
       http://cwashington.netreach.net/depo/view.asp?Index=103&ScriptType=python"""
    def __init__(self, type=1):
        if type == 0:
            self.chars = ['.', 'o', 'O', 'o']
        else:
            self.chars = ['|', '/', '-', '\\', '-']
        self.len  = len(self.chars)
        self.curr = 0

    def __str__(self):
        str = self.char()
        return("\b \b%s" % str)

    def char(self):
        self.curr = (self.curr + 1) % self.len
        return self.chars[self.curr]

    def done(self):
        sys.stdout.write("\b \b")

__build_cache_fail = []
__build_cache = []
def build(graph, item):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
	command = cmd
	debug(1, "oebuild %s %s" % (command, fn))
	event.fire(PkgStarted(item, pkgdata[fn]))
	try:
		oe.build.exec_task('do_%s' % command, pkgdata[fn])
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		return 1
	except oe.build.FuncFailed:
		error("task stack execution failed")
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0
	except oe.build.EventException:
		(type, value, traceback) = sys.exc_info()
		e = value.event
		error("%s event exception, aborting" % event.getName(e))
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0
#	opts = ""
#	if force:
#		opts += " --force"
#	ret = os.system("oebuild %s %s %s" % (opts, command, fn))
#	if ret == 0:
#		event.fire(PkgSucceeded(item, pkgdata[fn]))
#		__build_cache.append(item)
#		return 1
#	else:
#		event.fire(PkgFailed(item, pkgdata[fn]))
#		__build_cache_fail.append(item)
#		return 0

def getopthash(l):
	h = {}
	for (opt, val) in l:
		h[opt] = val
	return h

def usage():
	print
	print "Usage: oemake [options] [package ...]"
	print ""
	print "Builds specified packages, expecting that the .oe files"
	print "it has to work from are in OEFILES"
	print "Default packages are all packages in OEFILES."
	print "Default OEFILES are the .oe files in the current directory."
	print
	print "Options:"
	print "  %s\t\t%s" % ("-V, --version", "output version information and exit")
	print "  %s\t\t%s" % ("-c [arg], --cmd [arg]", "specify command to pass to oebuild")
	print "  %s\t\t%s" % ("-a, --abort", "abort build if any package build fails")
	print "  %s\t\t%s" % ("-f, --force", "force run of specified cmd, regardless of status")
	print
	print "Examples:"
	print "\toemake glibc"
	print "\toemake ncurses-5.3"
	print
	sys.exit(0)

__version__ = 1.1
def version():
	print "OpenEmbedded Build Infrastructure Core version %s" % oe.__version__
	print "OEMake version %s" % __version__

def get_oefiles():
	"""Get default oefiles"""
	dirs = os.listdir(os.getcwd())
	oefiles = []
	for f in dirs:
		(root, ext) = os.path.splitext(f)
		if ext == ".oe":
			oefiles.append(os.path.abspath(os.path.join(os.getcwd(),f)))
	return oefiles

def load_oefile(oefile, cfgdata):
	oepath = data.getVar('OEPATH', cfg)
	topdir = data.getVar('TOPDIR', cfg)
	if not topdir:
		topdir = os.path.abspath(os.getcwd())
		# set topdir to here
		data.setVar('TOPDIR', topdir, cfg)
	oefile = os.path.abspath(oefile)
	oefile_loc = os.path.abspath(os.path.dirname(oefile))
	# expand tmpdir to include this topdir
	data.setVar('TMPDIR', data.getVar('TMPDIR', cfg, 1) or "", cfg)
	# add topdir to oepath
	oepath += ":%s" % topdir
	# set topdir to location of .oe file
	topdir = oefile_loc
	#data.setVar('TOPDIR', topdir, cfg)
	# add that topdir to oepath
	oepath += ":%s" % topdir
	# go there
	oldpath = os.path.abspath(os.getcwd())
	os.chdir(topdir)
	data.setVar('OEPATH', oepath, cfg)
	oe = copy.deepcopy(cfgdata)
	try:
		parse.handle(oefile, oe) # read .oe data
		os.chdir(oldpath)
		return oe
	except IOError, OSError:
		os.chdir(oldpath)
		return None


#
# Handle options
#

try:
	(opts, args) = getopt.getopt(sys.argv[1:], 'Vc:fa', [ 'version', 'cmd=', 'abort', 'force' ])
except getopt.GetoptError:
	usage()

optsonly = [ opt for (opt,val) in opts]
cmd = None

opthash = getopthash(opts)

if opthash.has_key('--version') or opthash.has_key('-V'):
	version()
	sys.exit(0)

if opthash.has_key('--abort') or opthash.has_key('-a'):
	abort = 1
else:
	abort = 0

if opthash.has_key('--force') or opthash.has_key('-f'):
	force = 1
else:
	force = 0

if opthash.has_key('--cmd'):
	cmd = opthash['--cmd']
if opthash.has_key('-c'):
	cmd = opthash['-c']




_depcmds = { "clean": None,
	     "mrproper": None,
	     "build": "stage" }

if not cmd:
	cmd = "build"

if _depcmds.has_key(cmd):
	depcmd=_depcmds[cmd]
else:
	depcmd=cmd

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

try:
	cfg = parse.handle("conf/oe.conf", cfg)
except IOError:
	fatal("Unable to open oe.conf")

if not data.getVar("BUILDNAME", cfg):
	data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), cfg)

buildname = data.getVar("BUILDNAME", cfg)



#
# grab oefiles
#

files = string.split(data.getVar("OEFILES", cfg, 1) or "")
data.setVar("OEFILES", string.join(files), cfg)

if not len(files):
	files = get_oefiles()

if not len(files):
	usage()

parsespin = Spinner()
sys.stdout.write("NOTE: Parsing .oe files: %s" % parsespin.char())

for f in files:
	globbed = glob.glob(f) or [ f ]
	if globbed:
		if [ f ] != globbed:
			files += globbed
			continue
	# read a file's metadata
	try:
		debug(1, "oemake: parsing %s" % f)
		sys.stdout.write("\b \b%s" % parsespin.char())
		sys.stdout.flush()
		pkgdata[f] = load_oefile(f, cfg)
		deps = None
		if pkgdata[f] is not None:
			# allow metadata files to add items to OEFILES
			#data.update_data(pkgdata[f])
			addoefiles = data.getVar('OEFILES', pkgdata[f]) or None
			if addoefiles:
				for aof in string.split(addoefiles):
					if not files.count(aof):
						if not os.path.isabs(aof):
							aof = os.path.join(os.path.dirname(f),aof)
						files.append(aof)
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f], 1)
			if depstr is not None:
				deps = depstr.split()
			pkg = []
			pkg.append(data.getVar('CATEGORY', pkgdata[f], 1))
			pkg.append(data.getVar('PN', pkgdata[f], 1))
			pkg.append(data.getVar('PV', pkgdata[f], 1))
			pkg.append(data.getVar('PR', pkgdata[f], 1))
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			providestr = data.getVar("PROVIDES", pkgdata[f], 1)
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

sys.stdout.write("\n")

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if depcmd is not None:
		if deps is not None:
			for d in deps:
				if not graph.hasnode(d):
					def killitem(graph, item):
						global __tokill
						__tokill.append(item)
					graph.walkup(pkg, killitem)
					__unsatisfied.append([pkg, d])
					break
				graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	graph.walkup(k, reallykillitem)

event.fire(BuildStarted(buildname, graph.okeys, cfg))

pkgs_to_build = None
if args:
	if not pkgs_to_build:
		pkgs_to_build = []
	pkgs_to_build.extend(args)
if not pkgs_to_build:
	oepkgs = data.getVar('OEPKGS', cfg, 1)
	if oepkgs:
		pkgs_to_build = string.split(oepkgs)
if not pkgs_to_build:
	pkgs_to_build = graph.okeys
debug(1, "building: %s" % pkgs_to_build)

for k in pkgs_to_build:
	if pkgs.has_key(k):
		ret = graph.walkdown(k, build)
		if abort and not ret:
			fatal("Build of %s failed, aborting." % k)
	else:
		error("Unable to build %s: no .oe file provides it." % k)
		if abort:
			sys.exit(1)

event.fire(BuildCompleted(buildname, graph.okeys, cfg))
