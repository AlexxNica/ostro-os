#!/usr/bin/python

import string, sys, os
sys.path.append('/usr/share/oe')
from oe import *
import oe

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	pkg = property(getPkg, setPkg, None, "pkg property")

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	data = property(getData, setData, None, "data property")

class BuildBase(event.Event):
	"""Base class for oemake run events"""

	def __init__(self, n, p, c):
		self.name = n
		self.pkgs = p
		self.cfg = c

	def getPkgs(self):
		return self._pkgs

	def setPkgs(self, pkgs):
		self._pkgs = pkgs

	pkgs = property(getPkgs, setPkgs, None, "pkgs property")

	def getName(self):
		return self._name

	def setName(self, name):
		self._name = name

	name = property(getName, setName, None, "name property")

	def getCfg(self):
		return self._cfg

	def setCfg(self, cfg):
		self._cfg = cfg

	cfg = property(getCfg, setCfg, None, "cfg property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")
	
class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build succeeded"""

class BuildStarted(BuildBase):
	"""oemake build run started"""

class BuildCompleted(BuildBase):
	"""oemake build run completed"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

__build_cache_fail = []
__build_cache = []
def build(graph, item):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
	command = cmd
	debug(1, "oebuild %s %s" % (command, fn))
	event.fire(PkgStarted(item, pkgdata[fn]))
	ret = os.system("oebuild %s %s" % (command, fn))
	if ret == 0:
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		return 1
	else:
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0

def usage():
	print "Usage: oemake [options] [oefile ...]"
#	print "Run TASK on OEFILE or standard input if OEFILE is -."
	print "Run OEBuild's build task on a set of oe files, following"
	print "inter-package dependencies."
	print "Also obtains .oe files to build from the OEFILES environment variable."
	print "Example: oemake content/glibc-2.3.1.oe content/patcher-1.0.oe"
	print ""
	print "  %s\t\t%s" % ("-v, --version", "output version information and exit")
	sys.exit(0)

__version__ = 1.0
def version():
	print "OpenEmbedded Build Infrastructure Core version %s" % oe.__version__
	print "OEMake version %s" % __version__

def get_oefiles():
	"""Get default oefiles"""
	dirs = os.listdir(os.getcwd())
	oefiles = []
	for f in dirs:
		(root, ext) = os.path.splitext(f)
		if ext == ".oe":
			oefiles.append(os.path.abspath(os.path.join(os.getcwd(),f)))
	return oefiles

def get_oefile():
	"""Get default oefile"""
	oefiles = get_oefiles()
	if len(oefiles):
		return oefiles[0]
	else:
		return None


import getopt
try:
	(opts, args) = getopt.getopt(sys.argv[1:], 'vc:', [ 'version', 'cmd:' ])
except getopt.GetoptError:
	usage()

# handle opts
optsonly = [ opt for (opt,val) in opts]
cmd = None

def getopthash(l):
	h = {}
	for (opt, val) in l:
		h[opt] = val
	return h

opthash = getopthash(opts)

if opthash.has_key('--version') or opthash.has_key('-v'):
	version()
	sys.exit(0)

if opthash.has_key('--cmd'):
	cmd = opthash['--cmd']
if opthash.has_key('-c'):
	cmd = opthash['-c']

_depcmds = { "clean": None,
	     "mrproper": None,
	     "build": "stage", }

if not cmd:
	cmd = "build"

if _depcmds.has_key(cmd):
	depcmd=_depcmds[cmd]
else:
	depcmd=cmd

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

if not data.getVar("BUILDNAME", cfg):
	data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), cfg)

buildname = data.getVar("BUILDNAME", cfg)

# grab oefiles
files = string.split(data.getVar("OEFILES", cfg, 1) or "")
files += args
data.setVar("OEFILES", string.join(files), cfg)

if not len(files):
	files = get_oefiles()

if not len(files):
	usage()

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

#pkg = [ "pkgname", "depends", "provides" ]

import glob
for f in files:
	globbed = glob.glob(f) or [ f ]
	if globbed:
		if [ f ] != globbed:
			files += globbed
			continue
	# read a file's metadata
	try:
		from copy import deepcopy
		pkgdata[f] = parse.handle(f, deepcopy(cfg))
		deps = None
		if pkgdata[f] is not None:
			# allow metadata files to add items to OEFILES
			data.update_data(pkgdata[f])
			addoefiles = data.getVar('OEFILES', pkgdata[f]) or None
			if addoefiles:
				for aof in string.split(addoefiles):
					if not files.count(aof):
						if not os.path.isabs(aof):
							aof = os.path.join(os.path.dirname(f),aof)
						files.append(aof)
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f], 1)
			if depstr is not None:
				deps = depstr.split()
			pkg = []
			pkg.append(data.getVar('CATEGORY', pkgdata[f], 1))
			pkg.append(data.getVar('PN', pkgdata[f], 1))
			pkg.append(data.getVar('PV', pkgdata[f], 1))
			pkg.append(data.getVar('PR', pkgdata[f], 1))
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			# w/ category
			provides.append("%s/%s-%s" % (pkg[0], pkg[1], pkg[2]))
			provides.append("%s/%s" % (pkg[0], pkg[1]))
			# w/o category
			provides.append("%s" % pkg[1])
			provides.append("%s-%s" % (pkg[1], pkg[2]))
			provides.append("%s-%s-%s" % (pkg[1], pkg[2], pkg[3]))
			providestr = data.getVar("PROVIDES", pkgdata[f])
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if _depcmds[cmd] is not None:
		if deps is not None:
			for d in deps:
				if not graph.hasnode(d):
					def killitem(graph, item):
						global __tokill
						__tokill.append(item)
					graph.walkup(pkg, killitem)
					__unsatisfied.append([pkg, d])
					break
				graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	graph.walkup(k, reallykillitem)

event.fire(BuildStarted(buildname, graph.okeys, cfg))

for k in graph.okeys:
	graph.walkdown(k, build)

event.fire(BuildCompleted(buildname, graph.okeys, cfg))
