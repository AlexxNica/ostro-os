#!/usr/bin/python

import string, sys, os
from oe import *

class PkgFailed(event.Event):
	"""Package build failed"""
	type = "PkgFailed"

class PkgSucceeded(event.Event):
	"""Package build succeeded"""
	type = "PkgSucceeded"

def getBuildOrder(digraph):
	refcount = 0
	builddata = []
	dict = digraph.dict
	okeys = digraph.okeys
	
	for x in okeys:
		keyref = dict[x][0]
		if keyref > refcount:
			refcount = keyref
	
	maxcount = refcount
	
	while refcount >= 0:
		__found = 0
	
		for x in okeys:
			keycount = dict[x][0]
			if keycount == refcount:
				if keycount != 0 and depcmd is not None:
					command=depcmd
				else:
					command=cmd
	
				builddata.append([x, command])
				__found = 1
	
		refcount = refcount-1
	
	for x in okeys:
		if dict[x][0] != 0:
			builddata.append([x, cmd])

	return builddata

_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

pkgdata = {}
cfg = {}
graph = digraph()

parse.init(".conf", cfg)
data.setVarFlag("OEFILES", "inherit", "1", cfg)
data.setVarFlag("OEDIR", "inherit", "1", cfg)
data.setVarFlag("OEPATH", "inherit", "1", cfg)
data.setVarFlag("PATH", "inherit", "1", cfg)
data.inheritFromOS(1, cfg)

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

oefiles = data.getVar("OEFILES", cfg)
if oefiles is not None:
	files = oefiles.split()
else:
	fatal("OEFILES not defined")

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

for f in files:
	# read a file's metadata
	try:
		from copy import copy
		pkgdata[f] = parse.handle(f, copy(cfg))
#		if pkgdata[f] is not None:
#			data.emit_env(sys.__stdout__, pkgdata[f])
	except IOError:
		print "error opening %s" % f
		pass

	# use that metadata to yank the necessary bits for high
	# level build process.. the depends fields and provides info
	graph.addnode(f, None)
	
# Then, start the build for that package.  Note that because
# we've already loaded the files, we may as well spawn the build
# directly.. so lets abstract the task handling bits into a
# module that both oebuild and oemake can utilize.

data = getBuildOrder(graph)
for d in data:
	(pkg, step) = d 
	note("oebuild %s %s" % (step, pkg))
	os.system("oebuild %s %s" % (step, pkg))
