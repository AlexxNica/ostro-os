#!/usr/bin/python

import string, sys, os
from oe import *

class PkgFailed(event.Event):
	"""Package build failed"""
	type = "PkgFailed"

class PkgSucceeded(event.Event):
	"""Package build succeeded"""
	type = "PkgSucceeded"

def getParents(graph, item):
	if not graph.hasnode(item):
		return None
	return graph.dict[item][1]

def follow(graph, item, callback):
	if not graph.hasnode(item):
		return 0
	keycount = graph.dict[item][0]
	if keycount != 0 and depcmd is not None:
		command=depcmd
	else:
		command=cmd
	parents = getParents(graph, item)
	if parents is not None:
		for p in parents:
			ret = follow(graph, p, callback)
			if ret == 0:
				return 0
	return callback(item, command)

def addToBuild(data, graph, item):
	if not graph.hasnode(item):
		return 0
	keycount = graph.dict[item][0]
	if keycount != 0 and depcmd is not None:
		command=depcmd
	else:
		command=cmd
	parents = getParents(graph, item)
	if parents is not None:
		for p in parents:
			addToBuild(data, graph, p)
	if not [item, command] in data:
		data.append([item, command])
	return 1

_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

parse.init(".conf", cfg)
data.setVarFlag("OEFILES", "inherit", "1", cfg)
data.setVarFlag("OEDIR", "inherit", "1", cfg)
data.setVarFlag("OEPATH", "inherit", "1", cfg)
data.setVarFlag("PATH", "inherit", "1", cfg)
data.inheritFromOS(1, cfg)

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

oefiles = data.getVar("OEFILES", cfg)
if oefiles is not None:
	files = oefiles.split()
else:
	fatal("OEFILES not defined")

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

#pkg = [ "pkgname", "depends", "provides" ]

for f in files:
	# read a file's metadata
	try:
		from copy import copy
		pkgdata[f] = parse.handle(f, copy(cfg))
		deps = None
		if pkgdata[f] is not None:
			depstr = data.getVar("DEPENDS", pkgdata[f])
			if depstr is not None:
				deps = depstr.split()
			pkg = catpkgsplit(f)
			if pkg == None:
				continue
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			provides.append("%s/%s-%s" % (pkg[0], pkg[1], pkg[2]))
			provides.append("%s/%s" % (pkg[0], pkg[1]))
			providestr = data.getVar("PROVIDES", pkgdata[f])
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

# default provides.. a package provides itself, with and without
# version and revision

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

for pkg in pkgs.keys():
#	print "graph.addnode(%s, %s)" % (pkg, None)
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if deps is not None:
		for d in deps:
#			print "graph.addnode(%s, %s)" % (pkg, d)
			graph.addnode(pkg, d)
	
# Then, start the build for that package.  Note that because
# we've already loaded the files, we may as well spawn the build
# directly.. so lets abstract the task handling bits into a
# module that both oebuild and oemake can utilize.

__build_cache_fail = []
__build_cache = []
def build(item, command):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
	note("oebuild %s %s" % (command, fn))
	ret = os.system("oebuild %s %s" % (command, fn))
	if ret == 0:
		__build_cache.append(item)
		return 1
	else:
		__build_cache_fail.append(item)
		return 0
	
for k in graph.okeys:
	follow(graph, k, build)

#for d in data:
#	(pkg, step) = d 
#	if pkgs[pkg][1] is not None:
#		note("oebuild %s %s" % (step, pkgs[pkg][1]))
#		os.system("oebuild %s %s" % (step, pkgs[pkg][1]))
