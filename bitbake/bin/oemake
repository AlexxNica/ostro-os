#!/usr/bin/env python

import sys, os, getopt, glob, copy, os.path, re, sets
sys.path.append('/usr/share/oe')
import oe
from oe import make
from sets import Set

try:
    import itertools
except ImportError: # itertools appears in Python 2.3
    from utils import itertools
try:
    import optparse
except ImportError: # optparse appears in Python 2.3
    from utils import optparse
parsespin = itertools.cycle( r'|/-\-' )

__version__ = 1.1
__build_cache_fail = []
__build_cache = []
__building_list = []
__build_path = []

__preferred = {}
__world_target = Set()

def handle_options( args ):
        parser = optparse.OptionParser( version = "OpenEmbedded Build Infrastructure Core version %s, %%prog version %s" % ( oe.__version__, __version__ ),
        usage = """%prog [options] [package ...]

Builds specified packages, expecting that the .oe files
it has to work from are in OEFILES
Default packages are all packages in OEFILES.
Default OEFILES are the .oe files in the current directory.""" )

        parser.add_option( "-k", "--continue", help = "continue as much as possible after an error. While the target that failed, and those that depend on it, cannot be remade, the other dependencies of these targets can be processed all the same.",
                           action = "store_false", dest = "abort", default = True )

        parser.add_option( "-f", "--force", help = "force run of specified cmd, regardless of stamp status",
                           action = "store_true", dest = "force", default = False )


        parser.add_option( "-c", "--cmd", help = "specify command to pass to oebuild",
                           action = "store", dest = "cmd", default = "build" )

        parser.add_option( "-r", "--read", help = "read the specified file before oe.conf",
                           action = "append", dest = "file", default = [] )

	parser.add_option( "-v", "--verbose", help = "output more chit-chat to the terminal",
			   action = "store_true", dest = "verbose", default = False )

	parser.add_option( "-n", "--dry-run", help = "don't call oebuild, just go through the motions",
			   action = "store_true", dest = "dry_run", default = False )

        options, args = parser.parse_args( args )
        return options, args[1:]

def try_build(fn, virtual):
        if fn in __building_list:
            oe.error("%s depends on itself (eventually)" % fn)
	    oe.error("upwards chain is: %s" % (" -> ".join(__build_path)))
            return False

        __building_list.append(fn)

        the_data = make.pkgdata[fn]
        item = oe.data.getVar('PN', the_data, 1)
	pathstr = "%s (%s)" % (item, virtual)
        __build_path.append(pathstr)

        depends_list = (oe.data.getVar('DEPENDS', the_data, 1) or "").split()
	if make.options.verbose:
		oe.note("current path: %s" % (" -> ".join(__build_path)))
		oe.note("dependencies for %s are: %s" % (item, " ".join(depends_list)))

        try:
		for d in depends_list:
			if buildPackage(d) == 0:
				oe.error("dependency %s (for %s) not satisfied" % (d,item))
				return False

		command = make.options.cmd
		oe.debug(1, "oebuild %s %s" % (command, fn))
		oe.event.fire(oe.event.PkgStarted(item, make.pkgdata[fn]))
		try:
			if not make.options.dry_run:
				oe.build.exec_task('do_%s' % command, make.pkgdata[fn])
			oe.event.fire(oe.event.PkgSucceeded(item, make.pkgdata[fn]))
			__build_cache.append(fn)
			return True
		except oe.build.FuncFailed:
			oe.error("task stack execution failed")
			oe.event.fire(oe.event.PkgFailed(item, make.pkgdata[fn]))
			__build_cache_fail.append(fn)
			return False
		except oe.build.EventException:
			(type, value, traceback) = sys.exc_info()
			e = value.event
			oe.error("%s event exception, aborting" % oe.event.getName(e))
			oe.event.fire(oe.event.PkgFailed(item, make.pkgdata[fn]))
			__build_cache_fail.append(fn)
			return False
	finally:
		__building_list.remove(fn)
		__build_path.remove(pathstr)
		

def buildPackage(item):
        fn = None
        
        if not providers.has_key(item):
            oe.error("nothing provides %s" % item)
            return 0

        all_p = providers[item]

        for p in all_p:
            if p in __build_cache:
                return 1

        versions = {}
        for p in all_p:
            the_data = make.pkgdata[p]
            pn = oe.data.getVar('PN', the_data, 1)
            pv = oe.data.getVar('PV', the_data, 1)
            pr = oe.data.getVar('PR', the_data, 1)
            if not versions.has_key(pn):
                versions[pn] = []
            versions[pn].append(((pv, pr), p))

        # find the latest version of each provider
        preferred_versions = {}
        for p in versions.keys():
            latest = None
            latest_f = None
            for (v, _fn) in versions[p]:
                if (latest is None) or (make.vercmp(latest, v) < 0):
                    latest = v
                    latest_f = _fn
            preferred_versions[p] = (latest, latest_f)
            
        # build a new list with just the latest version of everything
        eligible = []
        for p in preferred_versions.keys():
            (v, f) = preferred_versions[p]
            eligible.append(f)
                
        for p in eligible:
            if item in __build_cache_fail:
                oe.debug(1, "rejecting already-failed %s" % p)
                eligible.remove(p)

        if len(eligible) == 0:
            oe.error("no eligible providers for %s" % item)
            return 0

        # look to see if one of them is already staged, or marked as preferred.
        # if so, bump it to the head of the queue
        for p in all_p:
            the_data = make.pkgdata[p]
            pn = oe.data.getVar('PN', the_data, 1)
            pv = oe.data.getVar('PV', the_data, 1)
            pr = oe.data.getVar('PR', the_data, 1)
            tmpdir = oe.data.getVar('TMPDIR', the_data, 1)
            stamp = '%s/stamps/%s-%s-%s.do_populate_staging' % (tmpdir, pn, pv, pr)
            if os.path.exists(stamp):
                (newvers, fn) = preferred_versions[pn]
                oldver = "%s-%s" % (pv, pr)
                newver = '-'.join(newvers)
                if (newver != oldver):
			extra_chat = "; upgrading from %s to %s" % (oldver, newver)
                else:
			extra_chat = ""
		if make.options.verbose:
			oe.note("selecting already-staged %s to satisfy %s%s" % (pn, item, extra_chat))
                eligible.remove(fn)
                eligible = [fn] + eligible
                break

        if __preferred.has_key(item):
		for p in eligible:
			the_data = make.pkgdata[p]
			pn = oe.data.getVar('PN', the_data, 1)
			if __preferred[item] == pn:
				if make.options.verbose:
					oe.note("selecting %s to satisfy %s due to PREFERRED_PROVIDERS" % (pn, item))
				eligible.remove(p)
				eligible = [p] + eligible
				break
                
        # run through the list until we find one that we can build
        for fn in eligible:
		oe.debug(2, "selecting %s to satisfy %s" % (fn, item))
		if try_build(fn, item):
			return 1

        oe.note("no buildable providers for %s" % item)
        return 0


def build_depgraph():
    all_depends = Set()
    pn_provides = {}
    
    for f in make.pkgdata.keys():
        d = make.pkgdata[f]
        
        pn = oe.data.getVar('PN', d, 1)

        deps = (oe.data.getVar("DEPENDS", d, 1) or "").split()
        provides = Set([pn] + (oe.data.getVar("PROVIDES", d, 1) or "").split())

        for dep in deps:
            all_depends.add(dep)

        if not pn_provides.has_key(pn):
            pn_provides[pn] = Set()
        pn_provides[pn] |= provides
        
        for provide in provides:
            if not providers.has_key(provide):
                providers[provide] = []
            providers[provide].append(f)

        for p in (oe.data.getVar('PREFERRED_PROVIDERS', d, 1) or "").split():
            (providee, provider) = p.split(':')
            if __preferred.has_key(providee) and __preferred[providee] != provider:
                oe.error("conflicting preferences for %s: both %s and %s specified" % (providee, provider, __preferred[providee]))
            __preferred[providee] = provider

    for f in make.pkgdata.keys():
        d = make.pkgdata[f]
        terminal = True
        pn = oe.data.getVar('PN', d, 1)
        for p in pn_provides[pn]:
            if p in all_depends or p.startswith('virtual/'):
                terminal = False
                break
        if terminal:
            __world_target.add(pn)

def myProgressCallback( x, y, f ):
    sys.stdout.write("\rNOTE: Parsing .oe files: %s (%04d/%04d) [%2d %%]" % ( parsespin.next(), x, y, x*100/y ) )
    sys.stdout.flush()

#
# main
#

if __name__ == "__main__":

    make.options, args = handle_options( sys.argv )

    _depcmds = { "clean": None,
                "mrproper": None,
                "build": "stage" }

    if not make.options.cmd:
            make.options.cmd = "build"

    if make.options.cmd in _depcmds:
            depcmd=_depcmds[make.options.cmd]
    else:
            depcmd=make.options.cmd

    make.pkgdata = {}
    make.cfg = {}
    providers = {}

    for f in make.options.file:
        try:
            make.cfg = oe.parse.handle(f, make.cfg)
        except IOError:
            oe.fatal("Unable to open %s" % f)

    try:
            make.cfg = oe.parse.handle("conf/oe.conf", make.cfg)
    except IOError:
            oe.fatal("Unable to open oe.conf")

    if not oe.data.getVar("BUILDNAME", make.cfg):
            oe.data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), make.cfg)

    buildname = oe.data.getVar("BUILDNAME", make.cfg)

    try:
        make.collect_oefiles( myProgressCallback )
	print
        build_depgraph()

        pkgs_to_build = None
        if args:
            if not pkgs_to_build:
                    pkgs_to_build = []
            pkgs_to_build.extend(args)
        if not pkgs_to_build:
            oepkgs = oe.data.getVar('OEPKGS', make.cfg, 1)
            if oepkgs:
                    pkgs_to_build = oepkgs.split()
        if not pkgs_to_build:
            print "nothing to build"
            sys.exit(0)

        if 'world' in pkgs_to_build:
            pkgs_to_build.remove('world')
            for t in __world_target:
                pkgs_to_build.append(t)

        oe.event.fire(oe.event.BuildStarted(buildname, pkgs_to_build, make.cfg))

        for k in pkgs_to_build:
            if buildPackage(k) == 0:
		print "Build of " + k + " failed"
		sys.exit(1)

        oe.event.fire(oe.event.BuildCompleted(buildname, pkgs_to_build, make.cfg))

    except KeyboardInterrupt:
        print "\nNOTE: KeyboardInterrupt - Build not completed."
