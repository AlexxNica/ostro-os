#!/usr/bin/python

import oe
import string

import oedata # data handling
oedata.init()

import oeparse # file parsing

def getBuildOrder(digraph):
	refcount = 0
	builddata = []
	dict = digraph.dict
	okeys = digraph.okeys
	
	for x in okeys:
		keyref = dict[x][0]
		if keyref > refcount:
			refcount = keyref
	
	maxcount = refcount
	
	while refcount >= 0:
		__found = 0
	
		for x in okeys:
			keycount = dict[x][0]
			if keycount == refcount:
				if keycount != 0 and depcmd is not None:
					command=depcmd
				else:
					command=cmd
	
				builddata.append([x, command])
				__found = 1
	
		refcount = refcount-1
	
	for x in okeys:
		if dict[x][0] != 0:
			builddata.append([x, cmd])

	return builddata

_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

files = []
files.append("test.oe")
files.append("conf/oe.conf")

pkgdata = {}

#cfgdata = oeparse.handle("../conf/oe.conf")
#from copy import copy
#testdata = oeparse.handle("../test.oe", copy(cfgdata))

for f in files:
	# read a file's metadata
	pkgdata[f] = oeparse.handle(f)
	print "pkgdata[%s]:" % f
	print "\t %s" % pkgdata[f]
	# use that metadata to yank the necessary bits for high
	# level build process.. the depends fields and provides info
	
	# Then, start the build for that package.  Note that because
	# we've already loaded the files, we may as well spawn the build
	# directly.. so lets abstract the task handling bits into a
	# module that both oebuild and oemake can utilize.


#test = oe.digraph()
#test.addnode("glibc", None)
#test.addnode("ipkg", "glibc")
#data = getBuildOrder(test)

#for d in data:
#	(pkg, step) = d 
#	print "oebuild %s %s-*.oe" % (step, pkg)
