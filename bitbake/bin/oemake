#!/usr/bin/python

import string, sys, os
from oe import *

class PkgBase(event.Event):
	"""Base class for package events"""

	def __init__(self, t, d = {}):
		self.pkg = t
		self.data = d

	def getPkg(self):
		return self._pkg

	def setPkg(self, pkg):
		self._pkg = pkg

	pkg = property(getPkg, setPkg, None, "pkg property")

	def getData(self):
		return self._data

	def setData(self, data):
		self._data = data

	data = property(getData, setData, None, "data property")

class BuildBase(event.Event):
	"""Base class for oemake run events"""

	def __init__(self, n, p, c):
		self.name = n
		self.pkgs = p
		self.cfg = c

	def getPkgs(self):
		return self._pkgs

	def setPkgs(self, pkgs):
		self._pkgs = pkgs

	pkgs = property(getPkgs, setPkgs, None, "pkgs property")

	def getName(self):
		return self._name

	def setName(self, name):
		self._name = name

	name = property(getName, setName, None, "name property")

	def getCfg(self):
		return self._cfg

	def setCfg(self, cfg):
		self._cfg = cfg

	cfg = property(getCfg, setCfg, None, "cfg property")

class DepBase(PkgBase):
	"""Base class for dependency events"""

	def __init__(self, t, data, d):
		self.dep = d
		PkgBase.__init__(self, t, data)

	def getDep(self):
		return self._dep

	def setDep(self, dep):
		self._dep = dep

	dep = property(getDep, setDep, None, "dep property")
	
class PkgStarted(PkgBase):
	"""Package build started"""

class PkgFailed(PkgBase):
	"""Package build failed"""

class PkgSucceeded(PkgBase):
	"""Package build succeeded"""

class BuildStarted(BuildBase):
	"""oemake build run started"""

class BuildCompleted(BuildBase):
	"""oemake build run completed"""

class UnsatisfiedDep(DepBase):
	"""Unsatisfied Dependency"""

class RecursiveDep(DepBase):
	"""Recursive Dependency"""

class MultipleProviders(PkgBase):
	"""Multiple Providers"""

# Then, start the build for that package.  Note that because
# we've already loaded the files, we may as well spawn the build
# directly.. so lets abstract the task handling bits into a
# module that both oebuild and oemake can utilize.

__build_cache_fail = []
__build_cache = []
def build(graph, item):
	if item in __build_cache:
		return 1
	if item in __build_cache_fail:
		return 0
	fn = pkgs[item][1]
	if fn is None:
		return 1
#	note("oebuild %s %s" % (command, fn))
	command = cmd
	event.fire(PkgStarted(item, pkgdata[fn]))
	ret = os.system("oebuild %s %s" % (command, fn))
	if ret == 0:
		event.fire(PkgSucceeded(item, pkgdata[fn]))
		__build_cache.append(item)
		return 1
	else:
		event.fire(PkgFailed(item, pkgdata[fn]))
		__build_cache_fail.append(item)
		return 0
	
_depcmds = { "do_clean": None,
	    "do_mrproper": None, }

cmd="do_build"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

pkgdata = {}
pkgs = {}
cfg = {}
graph = digraph()

try:
	cfg = parse.handle("conf/oe.conf", cfg)	# Read configuration
except IOError:
	fatal("Unable to open oe.conf")

if not data.getVar("BUILDNAME", cfg):
	data.setVar("BUILDNAME", os.popen('date +%Y%m%d%H%M').readline().strip(), cfg)

buildname = data.getVar("BUILDNAME", cfg)

oefiles = data.getVar("OEFILES", cfg)
if oefiles is not None:
	files = oefiles.split()
else:
	fatal("OEFILES not defined")

#set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

#pkg = [ "pkgname", "depends", "provides" ]

for f in files:
	# read a file's metadata
	try:
		from copy import copy
		pkgdata[f] = parse.handle(f, copy(cfg))
		deps = None
		if pkgdata[f] is not None:
			for var in pkgdata[f].keys():
				if data.getVarFlag(var, "handler", pkgdata[f]) and data.getVar(var, pkgdata[f]):
					event.register(data.getVar(var, pkgdata[f]))
			depstr = data.getVar("DEPENDS", pkgdata[f])
			if depstr is not None:
				deps = depstr.split()
			pkg = []
			pkg.append(data.getVar('CATEGORY', pkgdata[f]))
			pkg.append(data.getVar('PN', pkgdata[f]))
			pkg.append(data.getVar('PV', pkgdata[f]))
			pkg.append(data.getVar('PR', pkgdata[f]))
			root = "%s/%s-%s-%s" % (pkg[0], pkg[1], pkg[2], pkg[3])
			provides = []
			provides.append("%s/%s-%s" % (pkg[0], pkg[1], pkg[2]))
			provides.append("%s/%s" % (pkg[0], pkg[1]))
			providestr = data.getVar("PROVIDES", pkgdata[f])
			if providestr is not None:
				provides += providestr.split()
			for provide in provides:
				pkgs[provide] = [[root], None]
			pkgs[root] = [deps, f]
	except IOError:
		print "error opening %s" % f
		pass

# add every provide relationship to the dependency graph, depending
# on all the packages that provide it

global __tokill
global __unsatisfied
__tokill = []
__unsatisfied = []

for pkg in pkgs.keys():
	graph.addnode(pkg, None)

for pkg in pkgs.keys():
	(deps, fn) = pkgs[pkg]
	if deps is not None:
		for d in deps:
			if not graph.hasnode(d):
				def killitem(graph, item):
					global __tokill
					__tokill.append(item)
				graph.walkup(pkg, killitem)
				__unsatisfied.append([pkg, d])
				break
			graph.addnode(pkg, d)

for u in __unsatisfied:
	event.fire(UnsatisfiedDep(u[0], pkgdata[pkgs[u[0]][1]], u[1]))

for k in __tokill:
	def reallykillitem(graph, item):
		graph.delnode(item)
	graph.walkup(k, reallykillitem)

event.fire(BuildStarted(buildname, graph.okeys, cfg))

for k in graph.okeys:
	graph.walkdown(k, build)

event.fire(BuildCompleted(buildname, graph.okeys, cfg))
