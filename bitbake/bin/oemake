#!/usr/bin/python

import oe, string, sys, os

import oe.data # data handling
oe.data.init()

import oe.parse # file parsing

def getBuildOrder(digraph):
	refcount = 0
	builddata = []
	dict = digraph.dict
	okeys = digraph.okeys
	
	for x in okeys:
		keyref = dict[x][0]
		if keyref > refcount:
			refcount = keyref
	
	maxcount = refcount
	
	while refcount >= 0:
		__found = 0
	
		for x in okeys:
			keycount = dict[x][0]
			if keycount == refcount:
				if keycount != 0 and depcmd is not None:
					command=depcmd
				else:
					command=cmd
	
				builddata.append([x, command])
				__found = 1
	
		refcount = refcount-1
	
	for x in okeys:
		if dict[x][0] != 0:
			builddata.append([x, cmd])

	return builddata

_depcmds = { "clean": None,
	    "mrproper": None, }

cmd="package"

if _depcmds.has_key(cmd):
	depcmd=depcmds[cmd]
else:
	depcmd="stage"

files = []
files.append("../packages/content/glibc-2.3.1.oe")

pkgdata = {}

#cfgdata = oe.parse.handle("../conf/oe.conf")
#from copy import copy
#testdata = oe.parse.handle("../test.oe", copy(cfgdata))

cfg = {}
oe.parse.init(".conf", cfg)
oe.data.inheritFromOS(1, cfg)

__oepath_found_it__ = 0
for s in oe.data.getVar('OEPATH', cfg).split(":"):
	s = oe.data.expand(s, cfg)
	if os.access(os.path.join(s,'conf/oe.conf'), os.R_OK):
		__oepath_found_it__ = os.path.join(s, 'conf/oe.conf')

if __oepath_found_it__ == 0:
	oe.fatal("error locating conf/oe.conf")
else:
	cfg = oe.parse.handle(__oepath_found_it__, cfg)	# Read configuration

#oe.set_automatic_vars(sys.argv[2], )			# Deduce per-package environment variables

for f in files:
	# read a file's metadata
	try:
		from copy import copy
		pkgdata[f] = oe.parse.handle(f, copy(cfg))
		if pkgdata[f] is not None:
			oe.data.emit_env(sys.__stdout__, pkgdata[f])
	except IOError:
		pass

	# use that metadata to yank the necessary bits for high
	# level build process.. the depends fields and provides info
	
	# Then, start the build for that package.  Note that because
	# we've already loaded the files, we may as well spawn the build
	# directly.. so lets abstract the task handling bits into a
	# module that both oebuild and oemake can utilize.


#test = oe.digraph()
#test.addnode("glibc", None)
#test.addnode("ipkg", "glibc")
#data = getBuildOrder(test)
#for d in data:
#	(pkg, step) = d 
#	print "oebuild %s %s-*.oe" % (step, pkg)
