PATCHES_DIR="${S}"
DEPENDS_prepend="content/patcher "

python do_showdata() {
	import oe
	import sys
	# emit variables and shell functions
	oe.data.emit_env(sys.__stdout__, d)
	# emit the metadata which isnt valid shell
	for e in d.keys():
		if oe.data.getVarFlag(e, 'python', d):
			sys.__stdout__.write("\npython %s() {\n%s}\n" % (e, oe.data.getVar(e, d)))
}

python base_do_clean() {
	"""clear the build and temp directories"""
	from oe import note, data
	import os

	note("Executing task 'clean'")

	dir = data.expand("${TMPDIR}/${CATEGORY}/${PF}", d)
	if dir == '//': fatal("wrong DATADIR")
	note("removing " + dir)
	os.system('rm -rf ' + dir)

	dir = "%s.*" % data.expand(data.getVar('STAMP', d), d)
	note("removing " + dir)
	os.system('rm -f '+ dir)
}

python base_do_mrproper() {
	"""clear downloaded sources, build and temp directories"""
	from oe import note, debug, build
	import os

	note("Executing task 'mrproper'")

	dir = data.expand("${DL_DIR}", d)
	if dir == '/': fatal("wrong DATADIR")
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	build.exec_task('do_clean', d)
}

python base_do_patch () {
	import re, string
	from oe import decodeurl, encodeurl, note

	src_uri = data.getVar('SRC_URI', d)
	if not src_uri:
		note("no SRC_URI variable, nothing to be done")
		return
	src_uri = data.expand(src_uri, d)
	for url in src_uri.split():
#		note('url is %s' % url)
		(type, host, path, user, pswd, parm) = decodeurl(url)
		if not parm.has_key("patch"):
			continue
		from oe.fetch import init, localpath
		init([url])
		url = encodeurl((type, host, path, user, pswd, []))
		local = '/' + localpath(url)
		# patch!
		dots = local.split(".")
		if dots[-1] in ['gz', 'bz2', 'Z']:
			efile = os.path.join(data.getVar('WORKDIR', d),os.path.basename(string.join(dots[0:-1],".")))
		else:
			efile = local
		efile = data.expand(efile, d)
		patches_dir = data.expand(data.getVar('PATCHES_DIR', d), d)
		mkdirhier(patches_dir)
		os.chdir(patches_dir)
		path = data.getVar('PATH', d)
		if path:
			path = path.split(":")
			path[0:0] = [ os.path.join("${OEDIR}", "bin/build") ]
			path[0:0] = [ "${STAGING_BINDIR}" ]
			data.setVar('PATH', data.expand(string.join(path, ":"), d), d)
		cmd = "PATH=$PATH:%s patcher" % data.getVar('PATH', d)
		if parm.has_key("pnum"):
			cmd += " -p %s" % parm["pnum"]
		cmd += " -i %s" % efile
		ret = os.system(cmd)
		if ret != 0:
			raise FuncFailed("'patcher' execution failed")
}

python base_do_fetch() {
	import sys

	src_uri = data.getVar('SRC_URI', d)
	if not src_uri:
		note("no SRC_URI variable, nothing to be done")
		return 1
	src_uri = data.expand(src_uri, d)

	try:
		fetch.init(src_uri.split())
	except fetch.NoMethodError:
		(type, value, traceback) = sys.exc_info()
		error("No method: %s" % value)
		raise FuncFailed()

	try:
		fetch.go(d)
	except fetch.MissingParameterError:
		(type, value, traceback) = sys.exc_info()
		error("Missing parameters: %s" % value)
		raise FuncFailed()
	except fetch.FetchError:
		(type, value, traceback) = sys.exc_info()
		error("Fetch failed: %s" % value)
		raise FuncFailed()
}

base_do_unpack() {
	if test -z "${A}"; then
		oenote "nothing to extract"
		return
	fi
	unpack "${A}" || die "unpack failure"
}


base_do_compile() {
	if [ -x ${S}/configure ] ; then
		oe_runconf 
	fi
	if [ -e Makefile -o -e makefile ]; then
		oe_runmake || die "make failed"
	else
		oenote "nothing to compile"
	fi
}



base_do_stage() {
	oenote "nothing to install into stage area"
}


base_do_install() {
	oenote "nothing to install"
}

base_do_package() {
	oenote "nothing to package"
}

base_do_build() {
	oenote "nothing to do"
}

python base_eventhandler() {
	from oe import note, error, data
	from oe.event import Handled, NotHandled, getName
	import os, string

	name = getName(e)
	if name in ["PkgSucceeded", "PkgStarted"]:
		note("package %s: build %s" % (e.pkg, string.lower(name[3:])))
	elif name in ["PkgFailed"]:
		error("package %s: build %s" % (e.pkg, string.lower(name[3:])))
	elif name in ["TaskSucceeded", "TaskStarted"]:
		note("package %s: task %s %s" % (data.expand(data.getVar("PF", e.data), e.data), e.task, string.lower(name[4:])))
	elif name in ["TaskFailed"]:
		error("package %s: task %s %s" % (data.expand(data.getVar("PF", e.data), e.data), e.task, string.lower(name[4:])))
	elif name in ["UnsatisfiedDep"]:
		note("package %s: dependency %s %s" % (e.pkg, e.dep, string.lower(name[:-3])))
	elif name in ["BuildStarted", "BuildCompleted"]:
		note("build %s %s" % (e.name,string.lower(name[5:])))
	return NotHandled
}
addhandler base_eventhandler

# setup the initial task stack
EXPORT_FUNCTIONS do_clean do_mrproper do_fetch do_unpack do_compile do_stage do_install do_package do_patch do_build

addtask showdata
addtask clean
addtask mrproper
addtask fetch
addtask unpack after do_fetch
addtask patch after do_unpack
addtask compile after do_unpack do_patch
addtask stage after do_compile
addtask install after do_stage
addtask build after do_install
