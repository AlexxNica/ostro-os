PATCHES_DIR="${S}"
DEPENDS_prepend="patcher "

die () {
	return 1
}

oenote () {
	echo "NOTE:" $*
	return 0
}

oefatal () {
	echo "FATAL:" $*
	return 1
}

oedebug () {
	test $# -ge 2 || {
		echo "Usage: oedebug level \"message\""
		exit 1
	}
	
	test ${OEDEBUG:-0} -ge $1 && {
		shift
		echo "DEBUG:" $*
	}
	return 0
}

oeset () {
	test $# -eq 2 || {
		echo "Usage: oeset var value"
		exit 1
	}
	
	echo "TODO: setting $1 to '$2'"
}

oe_runmake () {
	if [ -f ./[mM]akefile -o -f ./GNUmakefile ] ; then
		if [ x"$MAKE" = x ]; then MAKE=make; fi
		oenote ${MAKE} ${EXTRA_OEMAKE} "$@"
		${MAKE} ${EXTRA_OEMAKE} "$@" || die "oemake failed"
	else
		die "no Makefile found"
	fi
}

python do_showdata() {
	import oe
	import sys
	# emit variables and shell functions
	oe.data.emit_env(sys.__stdout__, d)
	# emit the metadata which isnt valid shell
	for e in d.keys():
		if oe.data.getVarFlag(e, 'python', d):
			sys.__stdout__.write("\npython %s() {\n%s}\n" % (e, oe.data.getVar(e, d)))
}

python base_do_clean() {
	"""clear the build and temp directories"""
	from oe import note, data
	import os

	note("Executing task 'clean'")

	dir = data.expand("${TMPDIR}/${CATEGORY}/${PF}", d)
	if dir == '//': fatal("wrong DATADIR")
	note("removing " + dir)
	os.system('rm -rf ' + dir)

	dir = "%s.*" % data.expand(data.getVar('STAMP', d), d)
	note("removing " + dir)
	os.system('rm -f '+ dir)
}

python base_do_mrproper() {
	"""clear downloaded sources, build and temp directories"""
	from oe import note, debug, build
	import os

	note("Executing task 'mrproper'")

	dir = data.expand("${DL_DIR}", d)
	if dir == '/': fatal("wrong DATADIR")
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	build.exec_task('do_clean', d)
}

python base_do_patch () {
	import re, string
	from oe import decodeurl, encodeurl, note

	src_uri = data.getVar('SRC_URI', d)
	if not src_uri:
		note("no SRC_URI variable, nothing to be done")
		return
	src_uri = data.expand(src_uri, d)
	for url in src_uri.split():
#		note('url is %s' % url)
		(type, host, path, user, pswd, parm) = decodeurl(url)
		if not parm.has_key("patch"):
			continue
		from oe.fetch import init, localpath
		init([url])
		url = encodeurl((type, host, path, user, pswd, []))
		local = '/' + localpath(url)
		# patch!
		dots = local.split(".")
		if dots[-1] in ['gz', 'bz2', 'Z']:
			efile = os.path.join(data.getVar('WORKDIR', d),os.path.basename(string.join(dots[0:-1],".")))
		else:
			efile = local
		efile = data.expand(efile, d)
		patches_dir = data.expand(data.getVar('PATCHES_DIR', d), d)
		mkdirhier(patches_dir)
		os.chdir(patches_dir)
		path = data.getVar('PATH', d)
		if path:
			path = path.split(":")
			path[0:0] = [ os.path.join("${OEDIR}", "bin/build") ]
			path[0:0] = [ "${STAGING_BINDIR}" ]
			data.setVar('PATH', data.expand(string.join(path, ":"), d), d)
		cmd = "PATH=\"$PATH:%s\" patcher" % data.getVar('PATH', d)
		if parm.has_key("pnum"):
			cmd += " -p %s" % parm["pnum"]
		cmd += " -i %s" % efile
		ret = os.system(cmd)
		if ret != 0:
			raise FuncFailed("'patcher' execution failed")
}

python base_do_fetch() {
	import sys

	src_uri = data.getVar('SRC_URI', d)
	if not src_uri:
		note("no SRC_URI variable, nothing to be done")
		return 1
	src_uri = data.expand(src_uri, d)

	try:
		fetch.init(src_uri.split())
	except fetch.NoMethodError:
		(type, value, traceback) = sys.exc_info()
		error("No method: %s" % value)
		raise FuncFailed()

	try:
		fetch.go(d)
	except fetch.MissingParameterError:
		(type, value, traceback) = sys.exc_info()
		error("Missing parameters: %s" % value)
		raise FuncFailed()
	except fetch.FetchError:
		(type, value, traceback) = sys.exc_info()
		error("Fetch failed: %s" % value)
		raise FuncFailed()
}

python base_do_unpack() {
	import os
	src_uri = data.getVar('SRC_URI', d)
	if not src_uri:
		note("no SRC_URI variable, nothing to be done")
		return
	src_uri = data.expand(src_uri, d)
	for url in src_uri.split():
		# dont need any parameters for extraction, strip them off
		(scheme, loc, path, u, p, param) = oe.decodeurl(url)
		url = oe.encodeurl((scheme, loc, path, u, p, []))
		local = oe.data.expand(oe.fetch.localpath(url), d)
		cmd = None
		if local.endswith('.tar'):
			cmd = 'tar x --no-same-owner -f %s' % local
		elif local.endswith('.tgz') or local.endswith('.tar.gz'):
			cmd = 'tar xz --no-same-owner -f %s' % local
		elif local.endswith('.tbz') or local.endswith('.tar.bz2'):
			cmd = 'tar xj --no-same-owner -f %s' % local
		elif local.endswith('.gz') or local.endswith('.Z') or local.endswith('.z'):
			loc = local.rfind('.')
			cmd = 'gzip -dc %s > %s' % (local, local[:loc]) 
		elif local.endswith('.bz2'):
			loc = local.rfind('.')
			cmd = 'bzip2 -dc %s > %s' % (local, local[:loc]) 
		if not cmd:
			continue
		note("Unpacking %s to %s" % (local, os.getcwd()))
		ret = os.system(cmd)
		if ret != 0:
			raise FuncFailed()
}

base_do_configure() {
	oenote "nothing to configure"
}

base_do_compile() {
	if [ -e Makefile -o -e makefile ]; then
		oe_runmake || die "make failed"
	else
		oenote "nothing to compile"
	fi
}

base_do_stage() {
	oenote "nothing to install into stage area"
}


base_do_install() {
	oenote "nothing to install"
}

base_do_package() {
	oenote "nothing to package"
}

base_do_build() {
	oenote "nothing to do"
}

python base_eventhandler() {
	from oe import note, error, data
	from oe.event import Handled, NotHandled, getName
	import os, string

	name = getName(e)
	if name in ["PkgSucceeded", "PkgStarted"]:
		note("package %s: build %s" % (e.pkg, string.lower(name[3:])))
	elif name in ["PkgFailed"]:
		error("package %s: build %s" % (e.pkg, string.lower(name[3:])))
	elif name in ["TaskSucceeded", "TaskStarted"]:
		note("package %s: task %s %s" % (data.expand(data.getVar("PF", e.data), e.data), e.task, string.lower(name[4:])))
	elif name in ["TaskFailed"]:
		error("package %s: task %s %s" % (data.expand(data.getVar("PF", e.data), e.data), e.task, string.lower(name[4:])))
	elif name in ["UnsatisfiedDep"]:
		note("package %s: dependency %s %s" % (e.pkg, e.dep, string.lower(name[:-3])))
	elif name in ["BuildStarted", "BuildCompleted"]:
		note("build %s %s" % (e.name,string.lower(name[5:])))
	return NotHandled
}
addhandler base_eventhandler

# setup the initial task stack
EXPORT_FUNCTIONS do_clean do_mrproper do_fetch do_unpack do_configure do_compile do_stage do_install do_package do_patch do_build

addtask showdata
addtask clean
addtask mrproper
addtask fetch
addtask unpack after do_fetch
addtask patch after do_unpack
addtask configure after do_unpack do_patch
addtask compile after do_configure
addtask stage after do_compile
addtask install after do_stage
addtask build after do_install
