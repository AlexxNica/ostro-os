#!/usr/bin/python

import sys,os,string
from oe import *


#######################################################################

def exec_shell_func(func, dir=None, myfatal=fatal):
	"""This executes any shell function stored in env[func]. Returns
	true if execution was successful.

	For this, it creates a bash shell script in the tmp directory, writes the local
	environment in env[] into it and finally executes this. The output of the
	shell will end in a log file and stdout.
	"""

	global logfile
	mkdirhier(env['T'])
	logfile = env['T'] + '/log.fetch.' + str(os.getpid())
	runfile = env['T'] + '/run.fetch.' + str(os.getpid())

	f = open(runfile, "w")
	f.write("#!/bin/bash\n")
	if env.has_key('OEDEBUG'): f.write("set -x\n")
	f.write("source %s/bin/build/oebuild.sh\n" % env['OEDIR'])
	if env.has_key('OEPATH'):
		for s in env['OEPATH']:
			f.write("if -f %s/oebuild.sh && source $%s/oebuild.sh\n" % (s,s));
	emit_env(f)

	if dir:  f.write("cd %s\n" % env[dir])
	if func: f.write(func +"\n")
	f.close()
	os.chmod(runfile, 0775)
	if not func: return 1
	ret = os.system("bash -c 'source %s' 2>&1 | tee %s; exit $PIPESTATUS" % (runfile, logfile))
	if ret==0:
		if not env.has_key('OEDEBUG'): 
			os.remove(runfile)
			os.remove(logfile)
		return 0
	else:
		error("'%s'() failed" % func);
		myfatal("more info in: %s" % logfile);
		return 1



#######################################################################

def exec_task(task,dir):
	note("Executing task '%s'" % task)
	func = 'do_'+task
	ret = exec_shell_func(func, dir)
	if ret==0: mkstamp(task)

def mkstamp(task):
	mkdirhier(env['TMPDIR']+'/stamps');
	open(expand('${STAMP}')+task, "w+")

#TODO: teststamp, rmstamp


#######################################################################

def do_clean():
	"""clear the build and temp directories"""

	note("Executing task 'clean'")

	dir = expand("${TMPDIR}/${CATEGORY}/${PF}")
	if dir == '//': fatal("wrong DATADIR")
	note("removing " + dir)
	os.system('rm -rf ' + dir)

	dir = env['STAMP']+'.*'
	note("removing " + dir)
	os.system('rm -f '+ dir)


#######################################################################

def do_mrproper():
	"""clear downloaded sources, build and temp directories"""

	note("Executing task 'mrproper'")

	dir = env["DL_DIR"]
	if dir == '/': fatal("wrong DATADIR");
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	do_clean()


#######################################################################

def do_fetch():
	"""download needed sources"""

	mkdirhier(env["DL_DIR"])	# create file download directory

	note("Executing task 'fetch'")

	if env.has_key('SRC_URI'):
		ret = fetch(expand(env['SRC_URI']), 1)
		if ret:
			mkstamp('source')
	else:
		note("No SRC_URI variable, not downloading anything")


#######################################################################

def do_unpack():
	"""unpack downloaded sources, patch sources if needed"""

	mkdirhier(env["WORKDIR"])	# create workdir
	
	exec_task('unpack', 'WORKDIR')


#######################################################################

def do_compile():
	"""compile extracted sources"""

	mkdirhier(env["S"])		# create sourcedir if not yet existing
	exec_task('compile', 'S')


#######################################################################

def do_stage():
	"""install needed files to compile other packages into staging directory"""

	mkdirhier(env["S"])		# create sourcedir if not yet existing
	mkdirhier(env["STAGELIB"])
	mkdirhier(env["STAGEINC"])
	exec_task('stage', 'S')
		

#######################################################################

def do_install():
	"""install compiled files into image directory"""

	mkdirhier(env["S"])		# create sourcedir if not yet existing
	exec_task('install', 'S')
		

#######################################################################

def do_build():
	"""fetch, extract, compile, stage and install files"""
	
	do_fetch()
	print_orphan_env()
	print_missing_env()
	#emit_env()
	do_unpack()
	do_compile()
	do_stage()
	do_install()



#######################################################################

def do_test():
	"""internal"""

	ret = exec_shell_func(None)



#######################################################################

def do_showenv():
	"""internal

	Just for testing purposes. Displays all environment vars that
	are NOT automatically generated by oebuild, but are in the config
	file.

	Might give 'false positives' if some environment variable has not
	yet been documented in py's envflags{}.
	"""

	for s in env:
		if envflags.has_key(s): continue
		
		var = env[s]
		var = expand(var)

		if s == s.lower():
			print s + '() {\n' + var + '}'
		else:
			print s+'=' + var

	print_missing_env()
	print_orphan_env()


#######################################################################

def usage(errorlevel=0, txt=''):
	if txt:
		print
		print txt
	funcs = globals().keys()
	funcs.sort()

	print "\noebuild <command> <somebuildfile.oe>\n"
	print "Valid commands are:"
	for s in funcs:
		if s.startswith('do_'):
			doc = getattr(globals()[s], '__doc__')
			if doc.startswith('internal'): continue
			print "     %-15s %s" % (s[3:], doc)
	
	sys.exit(errorlevel)

if len(sys.argv) < 2:
	usage(1)
if sys.argv[1] in ('help', 'usage'):
	usage(0);
if len(sys.argv) < 3:
	usage(1)
	fatal("try 'oebuild <command> <somebuildfile.oe>'")

read_config(env['OEDIR']+'/conf/oe.conf')	# Read configuration
set_automatic_vars(sys.argv[2])			# Deduce per-package environment variables
try:
	read_oe(sys.argv[2])		# Read package configuration
except IOError:
	fatal("error accessing build file")
set_additional_vars()				# set rest of vars, e.g. ${A}
update_env()					# Environment modification, e.g. local overrides

for s in sys.argv[1].split(','):
	try:
		func = globals()['do_'+s]
	except KeyError:
		usage(1, "'%s' is not valid command" % s)
	func()

sys.exit(0)
