#!/usr/bin/python

import sys,os,string,oe


#######################################################################
#
# print_env()
#
# This prints the contents of oe.env[] so that it can later be sourced by a shell
# Normally, it prints to stdout, but this it can be redirectory to some open file handle
#
def print_env(o=sys.__stdout__):
	o.write('\nPATH="' + oe.projectdir + '/bin/build:${PATH}"\n')

	for s in oe.env:
		if s == s.lower(): continue

		o.write("\n")
		try: o.write('# ' + oe.envdesc[s]['desc'] + ':\n')
		except KeyError: pass
		if oe.envdesc.has_key(s) and oe.envdesc[s].has_key('export'): o.write("export ")

		o.write(s+'="'+oe.env[s]+'"\n')

	for s in oe.env:
		if s != s.lower(): continue

		o.write("\n" + s + '() {\n' + oe.env[s] + '}\n')


#######################################################################

def print_mkdir(o=sys.__stdout__):
	o.write("\n")
	o.write("# Create " + oe.envdesc['WORKDIR']['desc'] + ':\n')
	o.write("mkdir -p ${WORKDIR}\n")
	o.write("# Create " + oe.envdesc['S']['desc'] + ':\n')
	o.write("mkdir -p ${S}\n")
	o.write("# Create " + oe.envdesc['D']['desc'] + ':\n')
	o.write("mkdir -p ${D}\n")
	o.write("# Create " + oe.envdesc['T']['desc'] + ':\n')
	o.write("mkdir -p ${T}\n")


#######################################################################

def mkdir(dir):
	try:
		os.makedirs(dir)
		oe.debug(2, "created " + dir)
	except OSError, e:
		if e.errno != 17: raise e


#######################################################################

def do_todo():
	oe.fatal("oebuild %s is not yet implemented" % sys.argv[1])


#######################################################################

def do_clean():
	dir = oe.varexpand("${TMPDIR}/${CATEGORY}/${PF}", oe.env)
	oe.debug(2, "removing " + dir)
	os.spawnlp(os.P_WAIT, 'rm', 'rm', '-rf', dir)


#######################################################################

def do_mrproper():
	dir = oe.env["DISTDIR"]
	oe.debug(2, "removing " + dir)
	os.spawnlp(os.P_WAIT, 'rm', 'rm', '-rf', dir)
	do_clean()


#######################################################################

def do_fetch():
	mkdir(oe.env["DISTDIR"])	# create file download directory

	if oe.env.has_key('SRC_URI'):
		#print "TODO: fetch from ${SRC_URI}"
		oe.fetch(oe.env['SRC_URI'].split())

	if oe.env.has_key('pkg_fetch'):
		print "TODO: execute pkt_fetch"
		return

	if oe.env.has_key('pkp_nofetch'):
		print "TODO: execute pkg_nofetch"

#######################################################################

def do_build():
	oe.print_orphan_env()
	oe.print_missing_env()
	print_env()
	print_mkdir()
	#for s in ('pkg_setup', 'pkg_nofetch', 'pkg_fetch', 'src_compile', 'src_install'):
	#	if oe.env.has_key(s):
	#		print s,'|| die'



#######################################################################

def usage(errorlevel=0, txt=''):
	print "TODO: write better Usage"
	if txt: print txt
	sys.exit(errorlevel)

if sys.argv[1] in ('help', 'usage'):
	usage(0);

if len(sys.argv) < 3:
	oe.fatal("try 'oebuild <command> <somebuildfile.oe>'")

call_func = do_todo;

for arg in sys.argv[1].split(','):
	if arg == 'clean':
		# print 'TODO: clean the temporary build directory'
		call_func = do_clean
	elif arg == 'setup':
		print 'TODO: execute package specific setup actions'
	elif arg == 'fetch':
		#print 'TODO: fetch all source code'
		call_func = do_fetch
	elif arg == 'unpack':
		print 'TODO: extract the sources'
	elif arg == 'compile':
		print 'TODO: compile the sources'
	elif arg == 'stage':
		print 'TODO: install into the staging directory'
	elif arg == 'install':
		print 'TODO: install into the temporary install directory ${D}'
	elif arg == 'package':
		print 'TODO: create an installable package file, e.g. an ipk'
	elif arg == 'rootfs':
		print 'TODO: copy files into a root fs'
	elif arg == 'build':
		call_func = do_build;
	elif arg == 'digest':
		print 'TODO: for maintainers: create md5 digest files'
	elif arg == 'mrproper':
		#print 'TODO: clean the temporary build directory and sources for this package'
		call_func = do_mrproper
	else:
		usage(1);

	oe.read_oe_conf()			# Read configuration
	oe.set_automatic_vars(sys.argv[2])	# Deduce per-package environment variables
	oe.read_package_conf(sys.argv[2])	# Read package configuration
	oe.update_env()				# Environment modification

	call_func()				# call the function that does some real work

sys.exit(0)
