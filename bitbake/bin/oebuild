#!/usr/bin/python

import sys,os,string
import oefetch
sys.path.append(os.path.join(sys.prefix,'share/oe'))
from oe import *


#######################################################################

def exec_shell_func(func, dir=None, myfatal=fatal):
	"""This executes any shell function stored in env[func]. Returns
	true if execution was successful.

	For this, it creates a bash shell script in the tmp directory, writes the local
	environment in env[] into it and finally executes this. The output of the
	shell will end in a log file and stdout.
	"""

	global logfile
	mkdirhier(getenv('T'))
	logfile = getenv('T') + '/log.' + func + '.' + str(os.getpid())
	runfile = getenv('T') + '/run.' + func + '.' + str(os.getpid())

	f = open(runfile, "w")
	f.write("#!/bin/bash\n")
	if env.has_key('OEDEBUG'): f.write("set -x\n")
	if env.has_key('OEPATH'):
		for s in expand(env['OEPATH']).split(":"):
			f.write("if test -f %s/build/oebuild.sh; then source %s/build/oebuild.sh; fi\n" % (s,s));
	emit_env(f)

	if dir:  f.write("cd %s\n" % env[dir])
	if func: f.write(func +"\n")
	f.close()
	os.chmod(runfile, 0775)
	if not func: return 1
	ret = os.system("bash -c 'source %s' 2>&1 | tee %s; exit $PIPESTATUS" % (runfile, logfile))
	if ret==0:
		if not env.has_key('OEDEBUG'): 
			os.remove(runfile)
			os.remove(logfile)
		return 0
	else:
		error("'%s'() failed" % func);
		myfatal("more info in: %s" % logfile);
		return 1


def exec_python_func(func, dir = None, myfatal = fatal):
	os.chdir(getenv(dir))
	comp = compile(getenv(func),func,'exec')
	exec(comp)


#######################################################################

def exec_task(task, dir, deptasks = []):
	"""Executes a given task, handling the stamps appropriately"""
	if stamp_is_current(task, deptasks):
		return

	if not deptasks:
		try:
			deptasks = tasks[task]["deps"]
		except KeyError:
			pass

	for dep in deptasks:
		try:
			depfuncname = tasks[dep]["func"]
			depfunc = globals()[depfuncname]
			depfunc()
		except KeyError:
			debug(2, "invalid 'func' for task %s, running exec_task directly." % dep)
			try:
				exec_task(dep, dir, tasks[dep]["deps"])
			except:
				exec_task(dep, dir)

	func = 'do_'+task
	if not tasks.has_key(task):
		fatal("unsupported task: %s" % task)
		return 0

	note("Executing task '%s'" % task)

	if envflags.has_key(func) and envflags[func].has_key("python") and envflags[func]["python"] is not None:
#	if tasks[task].has_key("python") and tasks[task]["python"] is not None:
		# execute this function as a block of python code, not shell
		ret = exec_python_func(func, dir)
	else:
		ret = exec_shell_func(func, dir)
	if ret==0: mkstamp(task)

def mkstamp(task):
	"""Creates/updates a stamp for a given task"""
	mkdirhier(expand('${TMPDIR}/stamps'));
	open(getenv('STAMP')+"."+task, "w+")

def stamp_is_current(task, deptasks=""):
	"""Check status of a given task's stamp. returns False if it is not current and needs updating."""
	stampfile = getenv('STAMP') + "." + task
	if not os.access(stampfile, os.F_OK):
		return False

	import stat
	tasktime = os.stat(stampfile)[stat.ST_ATIME]

	for dep in deptasks:
		depfile = getenv('STAMP') + "." + dep
		deptime = os.stat(depfile)[stat.ST_ATIME]
		if deptime > tasktime:
			return False

	return True

#TODO: rmstamp


#######################################################################

def do_clean():
	"""clear the build and temp directories"""

	note("Executing task 'clean'")

	dir = expand("${TMPDIR}/${CATEGORY}/${PF}")
	if dir == '//': fatal("wrong DATADIR")
	note("removing " + dir)
	os.system('rm -rf ' + dir)

	dir = getenv('STAMP')+'.*'
	note("removing " + dir)
	os.system('rm -f '+ dir)


#######################################################################

def do_mrproper():
	"""clear downloaded sources, build and temp directories"""

	note("Executing task 'mrproper'")

	dir = getenv("DL_DIR")
	if dir == '/': fatal("wrong DATADIR");
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	do_clean()


#######################################################################

def do_fetch():
	"""download needed sources"""

	if stamp_is_current('fetch', tasks['fetch']['deps']):
		return

	mkdirhier(getenv("DL_DIR"))	# create file download directory

	note("Executing task 'fetch'")

	if env.has_key('SRC_URI'):
		grabber = oefetch.FetchUrls()
		try:
			grabber.init(getenv('SRC_URI').split())
		except oefetch.NoMethodError:
			fatal("No method for one or more urls in SRC_URI")
			return

		try:
			grabber.go()
		except oefetch.MissingParameterError:
			fatal("Fetch failed due to missing parameters in the supplied urls")
			return
		except oefetch.FetchError:
			fatal("Fetch failed")
			return
		mkstamp('fetch')
	else:
		fatal("No SRC_URI variable, not downloading anything")


#######################################################################

def do_unpack():
	"""unpack downloaded sources, patch sources if needed"""

	mkdirhier(env["WORKDIR"])	# create workdir
	
	exec_task('unpack', 'WORKDIR')


#######################################################################

def do_compile():
	"""compile extracted sources"""

	mkdirhier(env["S"])		# create sourcedir if not yet existing
	exec_task('compile', 'S')


#######################################################################

def do_stage():
	"""install needed files to compile other packages into staging directory"""

	mkdirhier(getenv("S"))		# create sourcedir if not yet existing
	mkdirhier(getenv("STAGING_LIBDIR"))
	mkdirhier(getenv("STAGING_BINDIR"))
	mkdirhier(getenv("STAGING_DIR") + "/build/include")
	mkdirhier(getenv("STAGING_DIR") + "/target/include")
	exec_task('stage', 'S')
		

#######################################################################

def do_install():
	"""install compiled files into image directory"""

	mkdirhier(env["S"])		# create sourcedir if not yet existing
	exec_task('install', 'S')
		

#######################################################################

def do_build():
	"""fetch, extract, compile, stage and install files"""
	
	do_fetch()
	print_orphan_env()
	print_missing_env()
	#emit_env()
	do_unpack()
	do_compile()
	do_stage()
	do_install()



#######################################################################

def do_test():
	"""internal"""

	ret = exec_shell_func(None)



#######################################################################

def do_showenv():
	"""internal

	Just for testing purposes. Displays all environment vars that
	are NOT automatically generated by oebuild, but are in the config
	file.

	Might give 'false positives' if some environment variable has not
	yet been documented in py's envflags{}.
	"""

	keys = env.keys()
	keys.sort()
	for s in keys:
		#if envflags.has_key(s): continue
		
		var = env[s]
		var = expand(var)

		if s == s.lower():
			print s + '() {\n' + var + '}'
		else:
			print s+'=' + var

	print_missing_env()
	print_orphan_env()


#######################################################################

def usage(errorlevel=0, txt=''):
	global tasks
	if txt:
		print
		print txt

	funcs = []
	for i in tasks.keys():
		if tasks[i].has_key("func"):
			funcs.append(tasks[i]["func"])
	funcs.sort()

	print "\noebuild <command> <somebuildfile.oe>\n"
	print "Valid commands are:"
	for s in funcs:
		if not globals().has_key(s):
			continue
		doc = getattr(globals()[s], '__doc__')
		if doc.startswith('internal'): continue
		print "     %-15s %s" % (s[3:], doc)
	
	sys.exit(errorlevel)

tasks = {
	"clean" : { "func" : "do_clean" },
	"mrproper" : { "func" : "do_mrproper" },
	"test" : { "func" : "do_test" },
	"showenv" : { "func" : "do_showenv" },
	"fetch" : { "func" : "do_fetch",
		     "deps" : [  ] },
	"unpack" : { "func" : "do_unpack",
		     "deps" : [ 'fetch' ] },
	"compile" : { "func" : "do_compile",
		      "deps" : [ 'unpack' ] },
	"stage" : { "func" : "do_stage",
		    "deps" : [ 'compile' ] },
	"install" : { "func" : "do_install",
		      "deps" : [ 'stage' ] },
	"package" : { "func" : "do_package",
		      "deps" : [ 'install' ] },
	"build" : { "func" : "do_build",
		    "deps" : [ 'package' ] },
}

if len(sys.argv) < 2:
	usage(1)
if sys.argv[1] in ('help', 'usage'):
	usage(0);
if len(sys.argv) < 3:
	usage(1)
	fatal("try 'oebuild <command> <somebuildfile.oe>'")

inherit_os_env(1)

__oepath_found_it__ = 0

for s in getenv('OEPATH').split(":"):
	if os.access(os.path.join(s,'conf/oe.conf'), os.R_OK):
		__oepath_found_it__ = 1
		try:
			read_config(os.path.join(s,'conf/oe.conf'))	# Read configuration
		except IOError:
			pass

if __oepath_found_it__ == 0:
	fatal("error locating conf/oe.conf")

set_automatic_vars(sys.argv[2])			# Deduce per-package environment variables
try:
	read_oe(sys.argv[2])		# Read package configuration
except IOError:
	fatal("error accessing build file")
set_additional_vars()				# set rest of vars, e.g. ${A}
update_env()					# Environment modification, e.g. local overrides

# check for functions to insert into the task stack
for var in env.keys():
	if not envflags.has_key(var):
		continue
	if not envflags[var].has_key("task"):
		continue

	h = var.split('_') # deal with task vs do_task inconsistency
	if not h[1]:
		continue
	taskvar = h[1]
	tasks[taskvar] = {}
	if envflags[var].has_key("func"):
		tasks[taskvar]["func"] = envflags[var]["func"]
	else:
		tasks[taskvar]["func"] = "INVALID"
	if envflags[var].has_key("deps"):
		# other tasks that we depend on
		tasks[taskvar]["deps"] = envflags[var]["deps"] 
	if envflags[var].has_key("postdeps"):
		# other tasks that depend on this one
		postdeps = envflags[var]["postdeps"]
		for t in tasks.keys():
			for i in postdeps:
				if t == i:
					if not tasks[t].has_key("deps"):
						tasks[t]["deps"] = []
					tasks[t]["deps"].append(taskvar)
					break
			
	if envflags[var].has_key("python"):
		tasks[taskvar]["python"] = "1"

for s in sys.argv[1].split(','):
	try:
		funcname = tasks[s]["func"]
		func = globals()[funcname]
		func()
	except KeyError:
		exec_task(s, "S")
#		INVALID()
#		usage(1, "'%s' is not valid command" % s)

sys.exit(0)
