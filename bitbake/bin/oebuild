#!/usr/bin/python

import sys,os,string,oe


#######################################################################
#
# print_env()
#
# This prints the contents of oe.env[] so that it can later be sourced by a shell
# Normally, it prints to stdout, but this it can be redirectory to some open file handle
#

def print_env(o=sys.__stdout__):
	o.write('\nPATH="' + oe.projectdir + '/bin/build:${PATH}"\n')

	for s in oe.env:
		if s == s.lower(): continue

		o.write("\n")
		try: o.write('# ' + oe.envdesc[s]['desc'] + ':\n')
		except KeyError: pass
		if oe.envdesc.has_key(s) and oe.envdesc[s].has_key('export'): o.write("export ")

		o.write(s+'="'+oe.env[s]+'"\n')

	for s in oe.env:
		if s != s.lower(): continue

		o.write("\n" + s + '() {\n' + oe.env[s] + '}\n')


#######################################################################
#
# exec_shell_func()
#
# This executes any shell function stored in env[func]
#

def exec_shell_func(func):
	global logfile
	mkdir(oe.env['T'])
	logfile = oe.env['T'] + '/log.fetch.' + str(os.getpid())
	runfile = oe.env['T'] + '/run.fetch.' + str(os.getpid())
	f = open(runfile, "w")
	f.write("#!/bin/bash\n")
	if oe.env.has_key('BDEBUG'): f.write("set -x\n")
	print_env(f)
	f.write("cd %s\n" % oe.env['DISTDIR'])
	f.write(func +"\n")
	f.close()
	os.chmod(runfile, 0775)
	#ret = os.system("bash -c 'source %s'" % runfile)
	#ret = os.system("bash -c 'source %s' >%s 2>&1" % (runfile, logfile))
	ret = os.system("bash -c 'source %s' 2>&1 | tee %s; exit $PIPESTATUS" % (runfile, logfile))
	if ret==0: os.remove(logfile)
	os.remove(runfile)
	return ret != 0


#######################################################################

def mkdir(dir):
	try:
		os.makedirs(dir)
		oe.debug(2, "created " + dir)
	except OSError, e:
		if e.errno != 17: raise e


#######################################################################

def do_todo():
	oe.fatal("oebuild %s is not yet implemented" % sys.argv[1])


#######################################################################

def do_clean():
	dir = oe.varexpand("${TMPDIR}/${CATEGORY}/${PF}", oe.env)
	if dir == '//': oe.fatal("wrong DATADIR");
	oe.debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)


#######################################################################

def do_mrproper():
	dir = oe.env["DISTDIR"]
	if dir == '/': oe.fatal("wrong DATADIR");
	oe.debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	do_clean()


#######################################################################

def do_fetch():
	mkdir(oe.env["DISTDIR"])	# create file download directory
	done = 0

	if oe.env.has_key('SRC_URI'):
		# TODO: correct error handling
		oe.fetch(oe.env['SRC_URI'].split())
		done = 1

	if oe.env.has_key('pkg_fetch'):
		ret = exec_shell_func('pkg_fetch')
		if ret == 0:
			done = 1
		else:
			oe.error('download via pkg_fetch() failed');
			oe.fatal('more info in: %s' % logfile);
		
	if done: return

	if oe.env.has_key('pkg_nofetch'):
		ret = exec_shell_func('pkg_nofetch')
		if ret != 0:
			oe.error('execution of pkg_nofetch() failed');
			oe.fatal('more info in: %s' % logfile);


#######################################################################

def do_unpack():
	mkdir(oe.env["WORKDIR"])	# create workdir
	
	if oe.env.has_key('src_unpack'):
		ret = exec_shell_func('src_unpack')
		if ret != 0:
			oe.error('unpacking source via src_unpack() failed');
			oe.fatal('more info in: %s' % logfile);
		return

	oe.fatal('TODO: add implicit source unpacking')
		

#######################################################################

def do_compile():
	#mkdir(oe.env["WORKDIR"])	# create workdir
	
	if oe.env.has_key('src_compile'):
		ret = exec_shell_func('src_compile')
		if ret != 0:
			oe.error('compilation via src_compile() failed');
			oe.fatal('more info in: %s' % logfile);
		return

	# do nothing if package needs no compile
		

#######################################################################

def do_build():
	oe.print_orphan_env()
	oe.print_missing_env()
	print_env()

	#for s in ('pkg_setup', 'pkg_nofetch', 'pkg_fetch', 'src_compile', 'src_install'):
	#	if oe.env.has_key(s):
	#		print s,'|| die'



#######################################################################

def usage(errorlevel=0, txt=''):
	print "TODO: write better Usage"
	if txt: print txt
	sys.exit(errorlevel)

if sys.argv[1] in ('help', 'usage'):
	usage(0);

if len(sys.argv) < 3:
	oe.fatal("try 'oebuild <command> <somebuildfile.oe>'")

oe.read_oe_conf()			# Read configuration
oe.set_automatic_vars(sys.argv[2])	# Deduce per-package environment variables
oe.read_package_conf(sys.argv[2])	# Read package configuration
oe.update_env()				# Environment modification

call_func = do_todo;

for arg in sys.argv[1].split(','):
	if arg == 'clean':
		# clean the temporary build directory
		call_func = do_clean
	elif arg == 'setup':
		print 'TODO: execute package specific setup actions'
	elif arg == 'fetch':
		# fetch all source code
		call_func = do_fetch
	elif arg == 'unpack':
		# extract the sources
		call_func = do_unpack
	elif arg == 'compile':
		# compile the sources
		call_func = do_compile
	elif arg == 'stage':
		print 'TODO: install into the staging directory'
	elif arg == 'install':
		print 'TODO: install into the temporary install directory ${D}'
	elif arg == 'package':
		print 'TODO: create an installable package file, e.g. an ipk'
	elif arg == 'rootfs':
		print 'TODO: copy files into a root fs'
	elif arg == 'build':
		call_func = do_build;
	elif arg == 'digest':
		print 'TODO: for maintainers: create md5 digest files'
	elif arg == 'mrproper':
		# clean the temporary build directory and sources for this package
		call_func = do_mrproper
	else:
		usage(1);

	call_func()				# call the function that does some real work

sys.exit(0)
