#!/usr/bin/python

import sys,os,string
from oe import *


#######################################################################

def emit_env(o=sys.__stdout__):
	"""This prints the contents of env[] so that it can later be sourced by a shell
	Normally, it prints to stdout, but this it can be redirectory to some open file handle

	It is used by exec_shell_func().
	"""

	o.write('\nPATH="' + projectdir + '/bin/build:${PATH}"\n')

	for s in env:
		if s == s.lower(): continue

		o.write('\n')
		try:
			o.write('# ' + envdesc[s]['desc'] + ':\n')
			if envdesc[s].has_key('export'): o.write('export ')
		except KeyError:
			pass

		o.write(s+'="'+env[s]+'"\n')

	for s in env:
		if s != s.lower(): continue

		o.write("\n" + s + '() {\n' + env[s] + '}\n')


#######################################################################

def exec_shell_func(func, myfatal=fatal):
	"""This executes any shell function stored in env[func]. Returns
	true if execution was successful.

	For this, it creates a bash shell script in the tmp directory, writes the local
	environment in env[] into it and finally executes this. The output of the
	shell will end in a log file and stdout.
	"""

	global logfile
	mkdirhier(env['T'])
	logfile = env['T'] + '/log.fetch.' + str(os.getpid())
	runfile = env['T'] + '/run.fetch.' + str(os.getpid())

	f = open(runfile, "w")
	f.write("#!/bin/bash\n")
	if env.has_key('OEDEBUG'): f.write("set -x\n")
	f.write("source %s/bin/build/oebuild.sh\n" % env['OEDIR'])
	if env.has_key('OEPATH'):
		for s in env['OEPATH']:
			f.write("if -f %s/oebuild.sh && source $%s/oebuild.sh\n" % (s,s));
	emit_env(f)
	f.write("cd %s\n" % env['DISTDIR'])

	f.write(func +"\n")
	f.close()
	os.chmod(runfile, 0775)
	ret = os.system("bash -c 'source %s' 2>&1 | tee %s; exit $PIPESTATUS" % (runfile, logfile))
	if ret==0:
		if not env.has_key('OEDEBUG'): 
			os.remove(runfile)
			os.remove(logfile)
		return 0
	else:
		error("'%s'() failed" % func);
		myfatal("more info in: %s" % logfile);
		return 1


#######################################################################

def do_todo():
	fatal("oebuild %s is not yet implemented" % sys.argv[1])


#######################################################################

def do_clean():
	dir = varexpand("${TMPDIR}/${CATEGORY}/${PF}", env)
	if dir == '//': fatal("wrong DATADIR");
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)


#######################################################################

def do_mrproper():
	dir = env["DISTDIR"]
	if dir == '/': fatal("wrong DATADIR");
	debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	do_clean()


#######################################################################

def do_fetch():
	mkdirhier(env["DISTDIR"])	# create file download directory
	done = 0
	ret = 0

	debug("do_fetch")
	if env.has_key('SRC_URI'):
		# TODO: correct error handling
		ret = fetch(varexpand(env['SRC_URI'], env), 1)
		done = 1
	else:
		note("No SRC_URI variable, not downloading anything")


#######################################################################

def do_unpack():
	mkdirhier(env["WORKDIR"])	# create workdir
	
	if env.has_key('src_unpack'):
		ret = exec_shell_func('src_unpack')
		if ret:
			error('unpacking source via src_unpack() failed');
			fatal('more info in: %s' % logfile);
		return

	fatal('TODO: add implicit source unpacking')
		

#######################################################################

def do_compile():
	if env.has_key('src_compile'):
		ret = exec_shell_func('src_compile')
		if ret:
			error('compilation via src_compile() failed');
			fatal('more info in: %s' % logfile);
		return
		

#######################################################################

def do_install():
	if env.has_key('src_install'):
		ret = exec_shell_func('src_install')
		if ret:
			error('installation via src_install() failed');
			fatal('more info in: %s' % logfile);
		return
		

#######################################################################

def do_build():
	do_fetch()
	print_orphan_env()
	print_missing_env()
	emit_env()
	do_unpack()
	do_compile()
	do_install()



#######################################################################

def do_showenv():
	"""Just for testing purposes. Displays all environment vars that
	are NOT automatically generated by oebuild, but are in the config
	file.

	Might give 'false positives' if some environment variable has not
	yet been documented in py's envdesc{}.
	"""

	for s in env:
		if envdesc.has_key(s): continue
		
		var = env[s]
		try:
			var = varexpand(var, env)
		except VarExpandError:
			pass

		if s == s.lower():
			print s + '() {\n' + var + '}'
		else:
			print s+'=' + var


#######################################################################

def usage(errorlevel=0, txt=''):
	print "TODO: write better Usage"
	if txt: print txt
	sys.exit(errorlevel)

if sys.argv[1] in ('help', 'usage'):
	usage(0);

if len(sys.argv) < 3:
	fatal("try 'oebuild <command> <somebuildfile.oe>'")

read_oe_conf()				# Read configuration
set_automatic_vars(sys.argv[2])		# Deduce per-package environment variables
read_package_conf(sys.argv[2])		# Read package configuration
update_env()				# Environment modification

call_func = do_todo;

for arg in sys.argv[1].split(','):
	if arg == 'clean':
		# clean the temporary build directory
		call_func = do_clean
	elif arg == 'setup':
		print 'TODO: execute package specific setup actions'
	elif arg == 'fetch':
		# fetch all source code
		call_func = do_fetch
	elif arg == 'unpack':
		# extract the sources
		call_func = do_unpack
	elif arg == 'compile':
		# compile the sources
		call_func = do_compile
	elif arg == 'install':
		# install the binaries
		call_func = do_install
	elif arg == 'stage':
		print 'TODO: install into the staging directory'
	elif arg == 'install':
		print 'TODO: install into the temporary install directory ${D}'
	elif arg == 'package':
		print 'TODO: create an installable package file, e.g. an ipk'
	elif arg == 'rootfs':
		print 'TODO: copy files into a root fs'
	elif arg == 'build':
		call_func = do_build;
	elif arg == 'showenv':
		call_func = do_showenv;
	elif arg == 'digest':
		print 'TODO: for maintainers: create md5 digest files'
	elif arg == 'mrproper':
		# clean the temporary build directory and sources for this package
		call_func = do_mrproper
	else:
		usage(1);

	call_func()				# call the function that does some real work

sys.exit(0)
