#!/usr/bin/python

import sys,os,string,oe


#######################################################################
#
# print_env()
#
# This prints the contents of oe.env[] so that it can later be sourced by a shell
# Normally, it prints to stdout, but this it can be redirectory to some open file handle
#
# It is used by exec_shell_func().
#

def print_env(o=sys.__stdout__):
	o.write('\nPATH="' + oe.projectdir + '/bin/build:${PATH}"\n')

	for s in oe.env:
		if s == s.lower(): continue

		o.write('\n')
		try: o.write('# ' + oe.envdesc[s]['desc'] + ':\n')
		except KeyError: pass
		if oe.envdesc.has_key(s) and oe.envdesc[s].has_key('export'): o.write('export ')

		o.write(s+'="'+oe.env[s]+'"\n')

	for s in oe.env:
		if s != s.lower(): continue

		o.write("\n" + s + '() {\n' + oe.env[s] + '}\n')


#######################################################################

def exec_shell_func(func):
	"""This executes any shell function stored in env[func]. Return if execution
	was successful.

	For this, it creates a bash shell script in the tmp directory, writes the local
	environment in oe.env[] into it and finally executes this. The output of the
	shell will end in a log file and stdout.
	"""

	global logfile
	mkdir(oe.env['T'])
	logfile = oe.env['T'] + '/log.fetch.' + str(os.getpid())
	runfile = oe.env['T'] + '/run.fetch.' + str(os.getpid())
	f = open(runfile, "w")
	f.write("#!/bin/bash\n")
	if oe.env.has_key('OEDEBUG'): f.write("set -x\n")
	print_env(f)
	f.write("cd %s\n" % oe.env['DISTDIR'])
	f.write(func +"\n")
	f.close()
	os.chmod(runfile, 0775)
	ret = os.system("bash -c 'source %s' 2>&1 | tee %s; exit $PIPESTATUS" % (runfile, logfile))
	if ret==0:
		os.remove(runfile)
		os.remove(logfile)
	return ret != 0


#######################################################################

def mkdir(dir):
	try:
		os.makedirs(dir)
		oe.debug(2, "created " + dir)
	except OSError, e:
		if e.errno != 17: raise e


#######################################################################

def do_todo():
	oe.fatal("oebuild %s is not yet implemented" % sys.argv[1])


#######################################################################

def do_clean():
	dir = oe.varexpand("${TMPDIR}/${CATEGORY}/${PF}", oe.env)
	if dir == '//': oe.fatal("wrong DATADIR");
	oe.debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)


#######################################################################

def do_mrproper():
	dir = oe.env["DISTDIR"]
	if dir == '/': oe.fatal("wrong DATADIR");
	oe.debug(2, "removing " + dir)
	os.system('rm -rf ' + dir)
	do_clean()


#######################################################################

def do_fetch():
	mkdir(oe.env["DISTDIR"])	# create file download directory
	done = 0
	ret = 0

	oe.debug("do_fetch")
	if oe.env.has_key('SRC_URI'):
		# TODO: correct error handling
		ret = oe.fetch(oe.varexpand(oe.env['SRC_URI'], oe.env), 1)
		done = 1
	else:
		oe.note("No SRC_URI variable, not downloading anything")


#######################################################################

def do_unpack():
	mkdir(oe.env["WORKDIR"])	# create workdir
	
	if oe.env.has_key('src_unpack'):
		ret = exec_shell_func('src_unpack')
		if ret != 0:
			oe.error('unpacking source via src_unpack() failed');
			oe.fatal('more info in: %s' % logfile);
		return

	oe.fatal('TODO: add implicit source unpacking')
		

#######################################################################

def do_compile():
	if oe.env.has_key('src_compile'):
		ret = exec_shell_func('src_compile')
		if ret != 0:
			oe.error('compilation via src_compile() failed');
			oe.fatal('more info in: %s' % logfile);
		return
		

#######################################################################

def do_install():
	if oe.env.has_key('src_install'):
		ret = exec_shell_func('src_install')
		if ret != 0:
			oe.error('installation via src_install() failed');
			oe.fatal('more info in: %s' % logfile);
		return
		

#######################################################################

def do_build():
	do_fetch()
	oe.print_orphan_env()
	oe.print_missing_env()
	print_env()
	do_unpack()
	do_compile()
	do_install()



#######################################################################

def do_showenv():
	"""Just for testing purposes. Displays all environment vars that
	are NOT automatically generated by oebuild, but are in the config
	file.

	Might give 'false positives' if some environment variable has not
	yet been documented in oe.py's envdesc{}.
	"""

	for s in oe.env:
		if oe.envdesc.has_key(s): continue
		
		var = oe.env[s]
		try:
			var = oe.varexpand(var, oe.env)
		except oe.VarExpandError:
			pass

		if s == s.lower():
			print s + '() {\n' + var + '}'
		else:
			print s+'=' + var


#######################################################################

def usage(errorlevel=0, txt=''):
	print "TODO: write better Usage"
	if txt: print txt
	sys.exit(errorlevel)

if sys.argv[1] in ('help', 'usage'):
	usage(0);

if len(sys.argv) < 3:
	oe.fatal("try 'oebuild <command> <somebuildfile.oe>'")

oe.read_oe_conf()			# Read configuration
oe.set_automatic_vars(sys.argv[2])	# Deduce per-package environment variables
oe.read_package_conf(sys.argv[2])	# Read package configuration
oe.update_env()				# Environment modification

call_func = do_todo;

for arg in sys.argv[1].split(','):
	if arg == 'clean':
		# clean the temporary build directory
		call_func = do_clean
	elif arg == 'setup':
		print 'TODO: execute package specific setup actions'
	elif arg == 'fetch':
		# fetch all source code
		call_func = do_fetch
	elif arg == 'unpack':
		# extract the sources
		call_func = do_unpack
	elif arg == 'compile':
		# compile the sources
		call_func = do_compile
	elif arg == 'install':
		# install the binaries
		call_func = do_install
	elif arg == 'stage':
		print 'TODO: install into the staging directory'
	elif arg == 'install':
		print 'TODO: install into the temporary install directory ${D}'
	elif arg == 'package':
		print 'TODO: create an installable package file, e.g. an ipk'
	elif arg == 'rootfs':
		print 'TODO: copy files into a root fs'
	elif arg == 'build':
		call_func = do_build;
	elif arg == 'showenv':
		call_func = do_showenv;
	elif arg == 'digest':
		print 'TODO: for maintainers: create md5 digest files'
	elif arg == 'mrproper':
		# clean the temporary build directory and sources for this package
		call_func = do_mrproper
	else:
		usage(1);

	call_func()				# call the function that does some real work

sys.exit(0)
