#!/usr/bin/python

import sys, os, string, oe
from oe import *

__version__ = 1.0
cfg_oe = data.init()

def usage():
	print "Usage: oeinstall [options ...]"
	print "Installs specified files of supported types into a root filesystem."
	print "Currently only supports installing OEFILES into the rootfs directly"
	print "using their do_install target."
	print ""
	print "  %s\t\t%s" % ("-r [arg], --root [arg]", "root directory (default=${IMAGE_ROOTFS})")
	print "  %s\t\t%s" % ("-f [arg], --files [arg]", ".oe files to install (default=${INSTALL_OEFILES})")
	print "  %s\t\t%s" % ("-t [arg], --type [arg]", "installation type (direct, and any for which package_[type].oeclass exists)")
	print "  %s\t\t%s" % ("-v, --version", "output version information and exit")
	sys.exit(0)

def version():
	print "OpenEmbedded Build Infrastructure Core version %s" % oe.__version__
	print "OEInstall version %s" % __version__

def getopthash(l):
	h = {}
	for (opt, val) in l:
		h[opt] = val
	return h

import getopt
try:
	(opts, args) = getopt.getopt(sys.argv[1:], 'vr:f:t:', [ 'version', 'root=', 'files=', 'type=' ])
except getopt.GetoptError:
	usage()

# handle opts
opthash = getopthash(opts)

if opthash.has_key('--version') or opthash.has_key('-v'):
	version()
	sys.exit(0)

try:
	cfg_oe = parse.handle("conf/oe.conf", cfg_oe)
except IOError:
	fatal("Unable to open oe.conf")

# sanity check
if cfg_oe is None:
	fatal("Unable to open/parse conf/oe.conf")
	usage(1)

rootfs = data.getVar('IMAGE_ROOTFS', cfg_oe, 1)

if opthash.has_key('--root'):
	rootfs = opthash['--root']
if opthash.has_key('-r'):
	rootfs = opthash['-r']

if not rootfs:
	oe.fatal("root filesystem not specified")

data.setVar('IMAGE_ROOTFS', rootfs, cfg_oe)

#type = 'direct'
type = 'tar'

if opthash.has_key('--type'):
	type = opthash['--type']
if opthash.has_key('-t'):
	type = opthash['-t']

# grab OEDIR
topdir = data.getVar('TOPDIR', cfg_oe, 1) or os.getcwd()
oedir = data.getVar('OEDIR', cfg_oe, 1) or topdir
mkdirhier(oedir)

# Iterate through .oe files
files = string.split(data.getVar("OEFILES", cfg_oe, 1) or "")
data.setVar("OEFILES", string.join(files), cfg_oe)

def get_oefiles():
	"""Get default oefiles"""
	dirs = os.listdir(os.getcwd())
	oefiles = []
	for f in dirs:
		(root, ext) = os.path.splitext(f)
		if ext == ".oe":
			oefiles.append(os.path.abspath(os.path.join(os.getcwd(),f)))
	return oefiles

if not len(files):
	files = get_oefiles()

if not len(files):
	usage()

# if type is not direct, add 'package_[type]' to INHERIT
if type is not 'direct':
	inherit = data.getVar('INHERIT', cfg_oe, 1) or ""
	inherit += " base package_%s" % type
	data.setVarFlag('INHERIT', 'export', 1, cfg_oe)
	data.setVar('INHERIT', inherit, cfg_oe)

import glob
for f in files:
	globbed = glob.glob(f) or [ f ]
	if globbed:
		if [ f ] != globbed:
			files += globbed
			continue
	from copy import deepcopy
	fdata = deepcopy(cfg_oe)
	parse.handle(f, fdata)
	if fdata is None:
		continue
	# allow metadata files to add items to OEFILES
	data.update_data(fdata)
	addoefiles = data.getVar('OEFILES', fdata) or None
	if addoefiles:
		for aof in string.split(addoefiles):
			if not files.count(aof):
				if not os.path.isabs(aof):
					aof = os.path.join(os.path.dirname(f),aof)
				files.append(aof)
	pkgs = string.split(data.getVar('PACKAGES', fdata, 1) or "")
	# Iterate through PACKAGES
	for p in pkgs:
		d = deepcopy(fdata)
		data.setVar('PKG', p, d)
		# Add package to overrides, collapse the metadata
		overrides = data.getVar('OVERRIDES', d, 1) or ""
		overrides += ":%s" % p
		data.setVar('OVERRIDES', overrides, d)
		data.update_data(d)
		data.setVarFlag('INHERIT', 'export', 1, d)
		# Look at vars to determine the file names for the package type in question
		# Call installer for a given package type as pulled from the metadata with INHERIT set properly
		if data.getVar('pkg_preinst', d):
			try:
				build.exec_func('pkg_preinst', d)
			except build.FuncFailed:
				continue
		if type is not 'direct':
			try:
				build.exec_func('package_%s_fn' % type, d)
			except build.FuncFailed:
				oe.error("failed obtaining the filename of the outputted package for %s" % type)
				continue
		if data.getVar('package_%s_install' % type, d):
			try:
				build.exec_func('package_%s_install' % type, d)
				print "package %s (%s) installed." % (p, data.getVar('PN', d, 1))
			except build.FuncFailed:
				continue
		else:
			oe.error("no package_%s_install function to execute. skipping." % type)
		if data.getVar('pkg_postinst', d):
			try:
				build.exec_func('pkg_postinst', d)
			except build.FuncFailed:
				pass
os.environ["D"] = rootfs
