TODO:

[x] oe package
	[x] Update .oe and .conf parsers to not strip out all the tabs in our 
	    python function vars..
	[x] Restructure
	[ ] Remove duplicated implementations, and convert everyone to the new
	    data and parse methods.
	[ ] API Sanity Audit.
	[ ] Comment/Docs Audit.
	[ ] Allow user supply of .oeclasses to be inherited in every file that
	    gets parsed via the INHERITS variable.
		[ ] Add default items to the beginning of INHERITS within
		    the parsers.  In this way, we can automatically pull in
		    base.oeclass for oe files, and build_an_srpm.oeclass for
		    .src.rpm files.

[ ] oebuild and oemake
	[ ] Teach the system to support grabbing OEFILES from upstream
	    using our fetch classes.

[ ] oebuild
	[ ] Use oe.digraph for handling intertask dependency
	[ ] Split task execution from function execution
	[ ] Revamp the way in which stamps are implemented
	[ ] Add a means to add a task which depends on another task's
	    execution, but not on said task's successful completion.

[.] oemake
	[x] Move OEPATH follow into the individual 'handle' functions,
	    whenever the fn path is relative.  Then kill the init call,
	    as it is really extraneous, given handle does it for you.
	[x] Add oe.conf parsing - abort if OEFILES is not defined
	[x] Add parsing of the .oe's listed in OEFILES
	[x] Handle provides in the digraph...
	[x] Handle dependency on just content/glibc vs content/glibc-2.3.1-r0
	[x] Proper event handling and failout when we encounter an unsatisfied
	    dependency.
	[ ] Check for recursive dependency
	[ ] Deal with multiple provides
	[ ] Pull package name, version, and revision based on package metadata,
	    rather than based on the filename in the build tools.  This belongs
	    in the parser code.  In this way, we can more easily facilitate
	    builds of src.rpms, .dsc's, et cetera.

[.] oemaked
	[x] Autobuilder daemon, monitors files and/or directories
	    For changes, and runs oemake when appropriate.
	[ ] Monitor the stamps for a given .oe file as well, to ensure
	    changes in build state as well as changes to build metadata result
	    in a rebuild.

[x] Update patcher tool to make use of our ability to use python functions.
[x] Write package.oeclass implemented w/ a python function/task
[x] Write src.rpm builder .oeclass
[ ] Write ipkg.oeclass which inherits package.oeclass to produce an ipk from
    our metadata.
[ ] Once we have the per package deployment code, write a staging oeclass
    that lets you use the FILES blocks for our deployment packages to do the
    installs into the appropriate staging areas, to save time writing do_stage
    functions.
[.] Finish up extensibility bits for the core oe code, and merge some of the
    class implementations into something sane.
[ ] Assuming cworth has the base ipkg libs rearchitected, start work on oemake.
    If he hasnt, start rearchitecting ipkg.
