<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter id="user-manual-metadata">
    <title>Metadata</title>

    <section>
        <title>Overview</title>

        <para>
            The BitBake task executor together with various types of configuration
            files form the OpenEmbedded Core.
            This section provides an overview of the task executor and the
            configuration files by describing their use and interaction.
        </para>

        <para>
            BitBake handles the parsing and execution of the data files.
            The data itself is of various types:
            <itemizedlist>
                <listitem><para><emphasis>Recipes:</emphasis>
                    Details about particular pieces of software.
                    </para></listitem>
                <listitem><para><emphasis>Class Data:</emphasis>
                    An abstraction of common build information
                    (e.g. how to build a Linux kernel).
                    </para></listitem>
                <listitem><para><emphasis>Configuration Data:</emphasis>
                    Machine-specific settings, policy decisions,
                    and so forth.
                    Configuration data acts as the glue to bind everything
                    together.</para></listitem>
            </itemizedlist>
            The remainder of this chapter provides examples of BitBake metadata.
            Any syntax not supported in any of the previously listed areas
            is documented as such.
        </para>
    </section>

    <section id='basic-syntax'>
        <title>Basic Syntax</title>

        <para>
            This section provides some basic syntax examples.
        </para>

        <section id='basic-variable-setting'>
            <title>Basic Variable Setting</title>

            <para>
                The following example sets <filename>VARIABLE</filename> to
                "value".
                This assignment occurs immediately as the statement is parsed.
                It is a "hard" assignment.
                <literallayout class='monospaced'>
     VARIABLE = "value"
                </literallayout>
            </para>
        </section>

        <section id='variable-expansion'>
            <title>Variable Expansion</title>

            <para>
                BitBake supports variables referencing one another's
                contents using a syntax that is similar to shell scripting.
                Following is an example that results in <filename>A</filename>
                containing "aval" and <filename>B</filename> containing
                "preavalpost".
                <literallayout class='monospaced'>
     A = "aval"
     B = "pre${A}post"
                </literallayout>
            </para>
        </section>

        <section id='setting-a-default-value'>
            <title>Setting a default value (?=)</title>

            <para>
                You can use the "?=" operator to achieve a "softer" assignment
                for a variable.
                This type of assignment allows you to define a variable if it
                is undefined when the statement is parsed, but to leave the
                value alone if the variable has a value.
                Here is an example:
                <literallayout class='monospaced'>
     A ?= "aval"
                </literallayout>
                If <filename>A</filename> is set at the time this statement is parsed,
                the variable retains its value.
                However, if <filename>A</filename> is not set,
                the variable is set to "aval".
                <note>
                    This assignment is immediate.
                    Consequently, if multiple "?=" assignments
                    to a single variable exist, the first of those ends up getting
                    used.
                </note>
            </para>
        </section>

        <section id='setting-a-weak-default-value'>
            <title>Setting a weak default value (??=)</title>

            <para>
                It is possible to use a "weaker" assignment that in the
                previous section by using the "??=" operator.
                This assignment behaves identical to "?=" except that the
                assignment is made at the end of the parsing process rather
                than immediately.
                Consequently, when multiple "??=" assignments exist, the last
                one is used.
                Also, any "=" or "?=" assignment will override the value set with
                "??=".
                Here is an example:
                <literallayout class='monospaced'>
     A ??= "somevalue"
     A ??= "someothervalue"
                </literallayout>
                If <filename>A</filename> is set before the above statements are parsed,
                the variable retains its value.
                If <filename>A</filename> is not set,
                the variable is set to "someothervalue".
            </para>

            <para>
                Again, this assignment is a "lazy" or "weak" assignment
                because it does not occur until the end
                of the parsing process.
            </para>
        </section>

        <section id='immediate-variable-expansion'>
            <title>Immediate variable expansion (:=)</title>

            <para>
                The ":=" operator results in a variable's
                contents being expanded immediately,
                rather than when the variable is actually used:
                <literallayout class='monospaced'>
     T = "123"
     A := "${B} ${A} test ${T}"
     T = "456"
     B = "${T} bval"
     C = "cval"
     C := "${C}append"
                </literallayout>
                In this example, <filename>A</filename> contains
                "test 123" because <filename>${B}</filename> and
                <filename>${A}</filename> at the time of parsing are undefined,
                which leaves "test 123".
                And, the variable <filename>C</filename>
                contains "cvalappend" since <filename>${C}</filename> immediately
                expands to "cval".
            </para>
        </section>

        <section id='appending-and-prepending'>
            <title>Appending (+=) and prepending (=+) With Spaces</title>

            <para>
                Appending and prepending values is common and can be accomplished
                using the "+=" and "=+" operators.
                These operators insert a space between the current
                value and prepended or appended value.
                Here are some examples:
                <literallayout class='monospaced'>
     B = "bval"
     B += "additionaldata"
     C = "cval"
     C =+ "test"
                </literallayout>
                The variable <filename>B</filename> contains
                "bval additionaldata" and <filename>C</filename>
                contains "test cval".
            </para>
        </section>

        <section id='appending-and-prepending-without-spaces'>
            <title>Appending (.=) and Prepending (=.) Without Spaces</title>

            <para>
                If you want to append or prepend values without an
                inserted space, use the ".=" and "=." operators.
                Here are some examples:
                <literallayout class='monospaced'>
     B = "bval"
     B .= "additionaldata"
     C = "cval"
     C =. "test"
                </literallayout>
                The variable <filename>B</filename> contains
                "bvaladditionaldata" and
                <filename>C</filename> contains "testcval".
            </para>
        </section>

        <section id='appending-and-prepending-override-style-syntax'>
            <title>Appending and Prepending (Override Style Syntax)</title>

            <para>
                You can also append and prepend a variable's value
                using an override style syntax.
                When you use this syntax, no spaces are inserted.
                Here are some examples:
                <literallayout class='monospaced'>
     B = "bval"
     B_append = " additional data"
     C = "cval"
     C_prepend = "additional data "
     D = "dval"
     D_append = "additional data"
                </literallayout>
                The variable <filename>B</filename> becomes
                "bval additional data" and <filename>C</filename> becomes
                "additional data cval".
                The variable <filename>D</filename> becomes
                "dvaladditional data".
                <note>
                    You must control all spacing when you use the
                    override syntax.
                </note>
            </para>
        </section>

        <section id='removing-override-style-syntax'>
            <title>Removal (Override Style Syntax)</title>

            <para>
                You can remove values from lists using the removal
                override style syntax.
                Specifying a value for removal causes all occurrences of that
                value to be removed from the variable.
            </para>

            <para>
                When you use this syntax, BitBake expects one or more strings.
                Surrounding spaces are removed as well.
                Here is an example:
                <literallayout class='monospaced'>
     FOO = "123 456 789 123456 123 456 123 456"
     FOO_remove = "123"
     FOO_remove = "456"
     FOO2 = "abc def ghi abcdef abc def abc def"
     FOO2_remove = "abc def"
                </literallayout>
                The variable <filename>FOO</filename> becomes
                "789 123456" and <filename>FOO2</filename> becomes
                "ghi abcdef".
            </para>
        </section>

        <section id='variable-flag-syntax'>
            <title>Variable Flag Syntax</title>

            <para>
                Variable flags are BitBake's implementation of variable properties
                or attributes.
                It is a way of tagging extra information onto a variable.
                You can find more out about variable flags in general in the
                "<link linkend='variable-flags'>Variable Flags</link>"
                section.
            </para>

            <para>
                You can define, append, and prepend values to variable flags.
                All the standard syntax operations previously mentioned work
                for variable flags except for override style syntax
                (i.e. <filename>_prepend</filename>, <filename>_append</filename>,
                and <filename>_remove</filename>).
            </para>

            <para>
                Here are some examples showing how to set variable flags:
                <literallayout class='monospaced'>
     FOO[a] = "abc"
     FOO[b] = "123"
     FOO[a] += "456"
                </literallayout>
                The variable <filename>FOO</filename> has two flags:
                <filename>a</filename> and <filename>b</filename>.
                The flags are immediately set to "abc" and "123", respectively.
                The <filename>a</filename> flag becomes "abc456".
            </para>
        </section>

        <section id='inline-python-variable-expansion'>
            <title>Inline Python Variable Expansion</title>

            <para>
                You can use inline Python variable expansion to
                set variables.
                Here is an example:
                <literallayout class='monospaced'>
     DATE = "${@time.strftime('%Y%m%d',time.gmtime())}"
                </literallayout>
                This example results in the <filename>DATE</filename>
                variable becoming the current date.
            </para>
        </section>
    </section>

    <section id='conditional-syntax-overrides'>
        <title>Conditional Syntax (Overrides)</title>

        <para>
            BitBake uses
            <link linkend='var-OVERRIDES'><filename>OVERRIDES</filename></link>
            to control what variables are overridden after BitBake
            parses recipes and configuration files.
            This section describes how you can use
            <filename>OVERRIDES</filename> as conditional metadata,
            talks about key expansion in relationship to
            <filename>OVERRIDES</filename>, and provides some examples
            to help with understanding.
        </para>

        <section id='conditional-metadata'>
            <title>Conditional Metadata</title>

            <para>
                You can use <filename>OVERRIDES</filename> to conditionally select
                a specific version of a variable and to conditionally
                append or prepend the value of a variable.
                <itemizedlist>
                    <listitem><para><emphasis>Selecting a Variable:</emphasis>
                        The <filename>OVERRIDES</filename> variable is
                        a colon-character-separated list that contains items
                        for which you want to satisfy conditions.
                        Thus, if you have a variable that is conditional on “arm”, and “arm”
                        is in <filename>OVERRIDES</filename>, then the “arm”-specific
                        version of the variable is used rather than the non-conditional
                        version.
                        Here is an example:
                        <literallayout class='monospaced'>
     OVERRIDES = "architecture:os:machine"
     TEST = "default"
     TEST_os = "osspecific"
     TEST_nooverride = "othercondvalue"
                        </literallayout>
                        In this example, the <filename>OVERRIDES</filename>
                        variable lists three overrides:
                        "architecture", "os", and "machine".
                        The variable <filename>TEST</filename> by itself has a default
                        value of "default".
                        You select the os-specific version of the <filename>TEST</filename>
                        variable by appending the "os" override to the variable
                        (i.e.<filename>TEST_os</filename>).
                        </para></listitem>
                    <listitem><para><emphasis>Appending and Prepending:</emphasis>
                        BitBake also supports append and prepend operations to
                        variable values based on whether a specific item is
                        listed in <filename>OVERRIDES</filename>.
                        Here is an example:
                        <literallayout class='monospaced'>
     DEPENDS = "glibc ncurses"
     OVERRIDES = "machine:local"
     DEPENDS_append_machine = "libmad"
                        </literallayout>
                        In this example, <filename>DEPENDS</filename> becomes
                        "glibc ncurses libmad".
                        </para></listitem>
                </itemizedlist>
            </para>
        </section>

        <section id='key-expansion'>
            <title>Key Expansion</title>

            <para>
                Key expansion happens when the BitBake data store is finalized
                just before BitBake expands overrides.
                To better understand this, consider the following example:
                <literallayout class='monospaced'>
     A${B} = "X"
     B = "2"
     A2 = "Y"
                </literallayout>
                In this case, after all the parsing is complete, and
                before any overrides are handled, BitBake expands
                <filename>${B}</filename> into "2".
                This expansion causes <filename>A2</filename>, which was
                set to "Y" before the expansion, to become "X".
            </para>
        </section>

        <section id='variable-interaction-worked-examples'>
            <title>Examples</title>

            <para>
                Despite the previous explanations that show the different forms of
                variable definitions, it can be hard to work
                out exactly what happens when variable operators, conditional
                overrides, and unconditional overrides are combined.
                This section presents some common scenarios along
                with explanations for variable interactions that
                typically confuse users.
            </para>

            <para>
                There is often confusion concerning the order in which
                overrides and various "append" operators take effect.
                Recall that an append or prepend operation using "_append"
                and "_prepend" does not result in an immediate assignment
                as would "+=", ".=", "=+", or "=.".
                Consider the following example:
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A = "Z"
     A_foo_append = "X"
                </literallayout>
                For this case, <filename>A</filename> is
                unconditionally set to "Z" and "X" is
                unconditionally and immediately appended to the variable
                <filename>A_foo</filename>.
                Because overrides have not been applied yet,
                <filename>A_foo</filename> is set to "X" due to the append
                and <filename>A</filename> simply equals "Z".
            </para>

            <para>
                Applying overrides, however, changes things.
                Since "foo" is listed in <filename>OVERRIDES</filename>,
                the conditional variable <filename>A</filename> is replaced
                with the "foo" version, which is equal to "X".
                So effectively, <filename>A_foo</filename> replaces <filename>A</filename>.
            </para>

            <para>
                This next example changes the order of the override and
                the append:
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A = "Z"
     A_append_foo = "X"
                </literallayout>
                For this case, before overrides are handled,
                <filename>A</filename> is set to "Z" and <filename>A_append_foo</filename>
                is set to "X".
                Once the override for "foo" is applied, however,
                <filename>A</filename> gets appended with "X".
                Consequently, <filename>A</filename> becomes "ZX".
                Notice that spaces are not appended.
            </para>

            <para>
                This next example has the order of the appends and overrides reversed
                back as in the first example:
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A = "Y"
     A_foo_append = "Z"
     A_foo_append += "X"
                </literallayout>
                For this case, before any overrides are resolved,
                <filename>A</filename> is set to "Y" using an immediate assignment.
                After this immediate assignment, <filename>A_foo</filename> is set
                to "Z", and then further appended with
                "X" leaving the variable set to "Z X".
                Finally, applying the override for "foo" results in the conditional
                variable <filename>A</filename> becoming "Z X" (i.e.
                <filename>A</filename> is replaced with <filename>A_foo</filename>).
            </para>

            <para>
                This final example mixes in some varying operators:
                <literallayout class='monospaced'>
     A = "1"
     A_append = "2"
     A_append = "3"
     A += "4"
     A .= "5"
                </literallayout>
                For this case, the type of append operators are affecting the
                order of assignments as BitBake passes through the code
                multiple times.
                Initially, <filename>A</filename> is set to "1 45" because
                of the three statements that use immediate operators.
                After these assignments are made, BitBake applies the
                <filename>_append</filename> operations.
                Those operations result in <filename>A</filename> becoming "1 4523".
            </para>
        </section>
    </section>

    <section id='sharing-functionality'>
        <title>Sharing Functionality</title>

        <para>
            BitBake allows for metadata sharing through include files and
            class files (<filename>.bbclass</filename>).
            For example, suppose you have a piece of common functionality
            such as a task definition that you want to share between
            more than one recipe.
            In this case, creating a <filename>.bbclass</filename>
            file that contains the common functionality and uses the
            <filename>inherit</filename> directive would be a common
            way to share the task.
        </para>

        <para>
            This section presents the mechanisms BitBake provides to
            allow you to share functionality between recipes.
            Specifically, the mechanisms include <filename>include</filename>,
            <filename>inherit</filename>, <filename>INHERIT</filename>, and
            <filename>require</filename> statements.
        </para>

        <section id='locating-include-and-class-files'>
            <title>Locating Include and Class Files</title>

            <para>
                BitBake uses the <filename>BBPATH</filename> variable
                to locate needed class and configuration files.
                The <filename>BBPATH</filename> variable is analogous to
                the environment variable <filename>PATH</filename>.
                Use of <filename>BBPATH</filename> is specific to the build
                environment (e.g. Yocto Project, OpenEmbedded, and so forth).
            </para>
        </section>

        <section id='inherit-directive'>
            <title><filename>inherit</filename> Directive</title>

            <para>
                When writing a recipe or class file, you can use the
                <filename>inherit</filename> directive to inherit the
                functionality of a class (<filename>.bbclass</filename>).
                BitBake only supports this directive when used within these
                two types of files (i.e. <filename>.bb</filename> and
                <filename>.bbclass</filename> files).
            </para>

            <para>
                The <filename>inherit</filename> directive is a rudimentary
                means of specifying what classes of functionality your
                recipe requires.
                For example, you can easily abstract out the tasks involved in
                building a package that uses Autoconf and Automake and put
                those tasks into a class file that can be used by your package.
                As an example, an <filename>autotools.bbclass</filename> file
                could use the following directive to inherit needed
                site information:
                <literallayout class='monospaced'>
     inherit siteinfo
                </literallayout>
                In this case, BitBake would search for the directory
                <filename>classes/siteinfo.bbclass</filename>
                in <filename>BBPATH</filename>.
            </para>
        </section>

        <section id='include-directive'>
            <title><filename>include</filename> Directive</title>

            <para>
                BitBake understands the <filename>include</filename>
                directive.
                This directive causes BitBake to parse whatever file you specify,
                and to insert that file at that location.
                The directive is much like Make except that if the path specified
                on the include line is a relative path, BitBake locates
                the first file it can find within <filename>BBPATH</filename>.
            </para>

            <para>
                As an example, suppose you needed a recipe to include some
                self-test files:
                <literallayout class='monospaced'>
     include test_recipe.inc
                </literallayout>
                <note>
                    The <filename>include</filename> directive does not
                    produce an error when the file cannot be found.
                    Consequently, it is recommended that if the file you
                    are including is expected to exist, you should use
                    <link linkend='require-inclusion'><filename>require</filename></link>
                    instead of <filename>include</filename>.
                    Doing so makes sure that an error is produced if the
                    file cannot be found.
                </note>
            </para>
        </section>

        <section id='require-inclusion'>
            <title><filename>require</filename> Directive</title>

            <para>
                BitBake understands the <filename>require</filename>
                directive.
                This directive behaves just like the
                <filename>include</filename> directive with the exception that
                BitBake raises a parsing error if the file to be included cannot
                be found.
                Thus, any file you require is inserted into the file that is
                being parsed at the location of the directive.
            </para>

            <para>
                Similar to how BitBake uses <filename>include</filename>,
                if the path specified
                on the require line is a relative path, BitBake locates
                the first file it can find within <filename>BBPATH</filename>.
            </para>

            <para>
                As an example, suppose you needed a recipe to require some
                self-test files:
                <literallayout class='monospaced'>
     require test_recipe.inc
                </literallayout>
            </para>
        </section>

        <section id='inherit-configuration-directive'>
            <title><filename>INHERIT</filename> Configuration Directive</title>

            <para>
                When creating a configuration file (<filename>.conf</filename>),
                you can use the <filename>INHERIT</filename> directive to
                inherit a class.
                BitBake only supports this directive when used within
                a configuration file.
            </para>

            <para>
                Suppose you needed to inherit a multilib global class.
                <literallayout class='monospaced'>
     INHERIT += "multilib_global"
                </literallayout>
                This configuration directive causes the named class to be inherited
                at the point of the directive during parsing.
            </para>
        </section>
    </section>

    <section id='functions'>
        <title>Functions</title>

        <note>
            This is only supported in <filename>.bb</filename>
            and <filename>.bbclass</filename> files.
        </note>

        <para>
            As with most languages, functions are the building blocks
            that define operations.
            Bitbake supports shell and Python functions.
            An example shell function definition is:
            <literallayout class='monospaced'>
     some_function () {
         echo "Hello World"
     }
            </literallayout>
            An example Python function definition is:
            <literallayout class='monospaced'>
     python some_python_function () {
         d.setVar("TEXT", "Hello World")
         print d.getVar("TEXT", True)
     }
            </literallayout>
            In python functions, the "bb" and "os" modules are already
            imported, there is no need to import those modules.
            The datastore, "d" is also a global variable and always
            available to these functions automatically.
        </para>

        <para>
            Bitbake will execute functions of this form using
            the <filename>bb.build.exec_func()</filename>, which can also be
            called from Python functions to execute other functions,
            either shell or Python based.
            Shell functions can only execute other shell functions.
        </para>

        <para>
            There is also a second way to declare python functions with
            parameters which takes the form:
            <literallayout class='monospaced'>
     def some_python_function(arg1, arg2):
         print arg1 + " " + arg2
            </literallayout>
            The difference is that the second form takes parameters,
            the datastore is not available automatically
            and must be passed as a parameter and these functions are
            not called with the <filename>exec_func()</filename> but are
            executed with direct Python function calls.
            The "bb" and "os" modules are still automatically available
            and there is no need to import them.
        </para>
    </section>

    <section id='defining-pure-python-functions'>
        <title>Defining Pure Python functions</title>

        <note>
            This is only supported in <filename>.bb</filename>
            and <filename>.bbclass</filename> files.
        </note>

        <para>
            For utility functions that you intend to call from
            in-line Python or other Python functions, BitBake allows
            you to define these as pure Python functions.
            Here is an example:
            <literallayout class='monospaced'>
     def get_depends(d):
         if d.getVar('SOMECONDITION', True):
             return "dependencywithcond"
         else:
             return "dependency"
     SOMECONDITION = "1"
     DEPENDS = "${@get_depends(d)}"
            </literallayout>
            This would result in <filename>DEPENDS</filename>
            containing <filename>dependencywithcond</filename>.
        </para>
    </section>

    <section id='tasks'>
        <title>Tasks</title>

        <note>
            This is only supported in <filename>.bb</filename>
            and <filename>.bbclass</filename> files.
        </note>

        <para>
            A shell or Python function executable through the
            <filename>exec_func</filename> can be promoted to become a task.
            Tasks are the execution unit Bitbake uses and each step that
            needs to be run for a given <filename>.bb</filename> is known as
            a task.
            There is an <filename>addtask</filename> command to add new tasks
            and promote functions which by convention must start with “do_”.
            The <filename>addtask</filename> command is also used to describe
            intertask dependencies.
            <literallayout class='monospaced'>
     python do_printdate () {
         import time print
         time.strftime('%Y%m%d', time.gmtime())
     }
     addtask printdate after do_fetch before do_build
            </literallayout>
            The above example defined a Python function, then adds
            it as a task which is now a dependency of
            <filename>do_build</filename>, the default task and states it
            has to happen after <filename>do_fetch</filename>.
            If anyone executes the <filename>do_build</filename>
            task, that will result in <filename>do_printdate</filename>
            being run first.
        </para>
    </section>

    <section id='running-a-task'>
        <title>Running a Task</title>

        <para>
            Tasks can either be a shell task or a Python task.
            For shell tasks, BitBake writes a shell script to
            <filename>${WORKDIR}/temp/run.do_taskname.pid</filename>
            and then executes the script.
            The generated shell script contains all the exported variables,
            and the shell functions with all variables expanded.
            Output from the shell script goes to the file
            <filename>${WORKDIR}/temp/log.do_taskname.pid</filename>.
            Looking at the expanded shell functions in the run file and
            the output in the log files is a useful debugging technique.
        </para>

        <para>
            For Python tasks, BitBake executes the task internally and logs
            information to the controlling terminal.
            Future versions of BitBake will write the functions to files
            similar to the way shell tasks are handled.
            Logging will be handled in a way similar to shell tasks as well.
        </para>

        <para>
            Once all the tasks have been completed BitBake exits.
        </para>

        <para>
            When running a task, BitBake tightly controls the execution
            environment of the build tasks to make
            sure unwanted contamination from the build machine cannot
            influence the build.
            Consequently, if you do want something to get passed into the
            build task's environment, you must take a few steps:
            <orderedlist>
                <listitem><para>
                    Tell BitBake to load what you want from the environment
                    into the data store.
                    You can do so through the
                    <filename>BB_ENV_EXTRAWHITE</filename> variable.
                    For example, assume you want to prevent the build system from
                    accessing your <filename>$HOME/.ccache</filename>
                    directory.
                    The following command tells BitBake to load
                    <filename>CCACHE_DIR</filename> from the environment into
                    the data store:
                    <literallayout class='monospaced'>
     export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE CCACHE_DIR"
                    </literallayout></para></listitem>
                <listitem><para>
                    Tell BitBake to export what you have loaded into the
                    environment store to the task environment of
                    every running task.
                    Loading something from the environment into the data
                    store (previous step) only makes it available in the datastore.
                    To export it to the task environment of every running task,
                    use a command similar to the following in your
                    <filename>local.conf</filename> or distribution configuration file:
                    <literallayout class='monospaced'>
     export CCACHE_DIR
                    </literallayout>
                    <note>
                        A side effect of the previous steps is that BitBake
                        records the variable as a dependency of the build process
                        in things like the shared state checksums.
                        If doing so results in unnecessary rebuilds of tasks, you can
                        whitelist the variable so that the shared state code
                        ignores the dependency when it creates checksums.
                    </note></para></listitem>
            </orderedlist>
        </para>
    </section>

    <section id='variable-flags'>
        <title>Variable Flags</title>

        <para>
            This section describes variable flags.
        </para>
    </section>

    <section id='task-flags'>
        <title>Task Flags</title>

        <para>
            Tasks support a number of flags which control various
            functionality of the task.
            These are as follows:
            <itemizedlist>
                <listitem><para><emphasis>dirs:</emphasis>
                    Directories which should be created before the task runs.
                    </para></listitem>
                <listitem><para><emphasis>cleandirs:</emphasis>
                    Directories which should created before the task runs
                    but should be empty.</para></listitem>
                <listitem><para><emphasis>noexec:</emphasis>
                    Marks the tasks as being empty and no execution required.
                    These are used as dependency placeholders or used when added tasks
                    need to be subsequently disabled.</para></listitem>
                <listitem><para><emphasis>nostamp:</emphasis>
                    Do not generate a stamp file for a task.
                    This means the task is always executed.</para></listitem>
                <listitem><para><emphasis>fakeroot:</emphasis>
                    This task needs to be run in a fakeroot environment,
                    obtained by adding the variables in <filename>FAKEROOTENV</filename>
                    to the environment.</para></listitem>
                <listitem><para><emphasis>umask:</emphasis>
                    The umask to run the task under.</para></listitem>
            </itemizedlist>
            For the 'deptask', 'rdeptask', 'depends', 'rdepends'and
            'recrdeptask' flags, please see the dependencies section.
        </para>
    </section>

    <section id='parsing-and-execution'>
        <title>Parsing and Execution</title>

        <section id='parsing-overview'>
            <title>Parsing Overview</title>

            <para>
                BitBake parses configuration files, classes, and
                <filename>.bb</filename> files.
            </para>

            <para>
                The first thing BitBake does is look for the
                <filename>bitbake.conf</filename> file.
                This file resides in the within the <filename>conf/</filename>
                directory.
                BitBake finds it by examining its <filename>BBPATH</filename>
                environment variable and looking for the
                <filename>conf/</filename> directory.
            </para>

            <para>
                The <filename>bitbake.conf</filename> file lists other configuration
                files to include from a <filename>conf/</filename> directory below the
                directories listed in <filename>BBPATH</filename>.
                In general, the most important configuration file from a user's perspective
                is <filename>local.conf</filename>, which contains a user's
                customized settings for the build environment.
                Other notable configuration files are the distribution configuration
                file (set by the <filename>DISTRO</filename> variable) and the machine
                configuration file (set by the <filename>MACHINE</filename> variable).
                The <filename>DISTRO</filename> and <filename>MACHINE</filename> BitBake
                environment variables are both usually set in the
                <filename>local.conf file</filename>.
                Valid distribution configuration files are available
                in the <filename>conf/distro/</filename> directory and valid machine
                configuration files in the <filename>meta/conf/machine/</filename>
                directory.
                Within the <filename>conf/machine/include/</filename> directory are
                various <filename>tune-*.inc</filename> configuration files
                that provide common "tuning" settings specific to and shared between
                particular architectures and machines.
            </para>

            <para>
                After parsing of the configuration files, some standard classes are
                included.
                The <filename>base.bbclass</filename> file
                is always included.
                Other classes that are specified in the configuration using the
                <filename>INHERIT</filename> variable are also included.
                Class files are searched for in a classes subdirectory under
                the paths in <filename>BBPATH</filename> in the same way as
                configuration files.
            </para>

            <para>
                After classes are included, the variable
                <filename>BBFILES</filename> is set, usually in
                <filename>local.conf</filename>, and defines the list of
                places to search for <filename>.bb</filename> files.
                Adding extra content to <filename>BBFILES</filename> is best
                achieved through the use of BitBake layers as described in the
                Layers section below.
            </para>

            <para>
                BitBake parses each <filename>.bb</filename> file in
                <filename>BBFILES</filename> and stores the values of various
                variables.
                In summary, for each <filename>.bb</filename> file the configuration
                plus the base class of variables are set, followed by the data in the
                <filename>.bb</filename> file itself, followed by any inherit commands
                that <filename>.bb</filename> file might contain.
            </para>

            <para>
                Because parsing <filename>.bb</filename> files is a time consuming
                process, a cache is kept to speed up subsequent parsing.
                This cache is invalid if the timestamp of the
                <filename>.bb</filename> file itself changes, or if the timestamps of
                any of the include, configuration files or class files on which
                the <filename>.bb</filename> file depends change.
            </para>
        </section>

        <section id='parsing-configuration-files'>
            <title>Configuration files</title>

            <para>
                The first kind of metadata in BitBake is configuration metadata.
                This metadata is global, and therefore affects all packages and
                tasks that are executed.
            </para>

            <para>
                BitBake will first search the current working directory for an
                optional <filename>conf/bblayers.conf</filename> configuration file.
                This file is expected to contain a <filename>BBLAYERS</filename>
                variable that is a space delimited list of 'layer' directories.
                For each directory in this list, a <filename>conf/layer.conf</filename>
                file will be searched for and parsed with the
                <filename>LAYERDIR</filename> variable being set to the directory where
                the layer was found.
                The idea is these files will setup <filename>BBPATH</filename>
                and other variables correctly for a given build directory automatically
                for the user.
            </para>

            <para>
                BitBake will then expect to find <filename>conf/bitbake.conf</filename>
                file somewhere in the user specified <filename>BBPATH</filename>.
                That configuration file generally has include directives to pull
                in any other metadata (generally files specific to architecture,
                machine, local and so on).
            </para>

            <para>
                Only variable definitions and include directives are allowed
                in <filename>.conf</filename> files.
            </para>

            <section id='layers'>
                <title>Layers</title>

                <para>
                    Layers allow you to isolate different types of
                    customizations from each other.
                    You might find it tempting to keep everything in one layer
                    when working on a single project.
                    However, the more modular you organize your Metadata, the
                    easier it is to cope with future changes.
                </para>

                <para>
                    To illustrate how layers are used to keep things modular,
                    consider machine customizations.
                    These types of customizations typically reside in a special layer,
                    rather than a general layer, called a Board Specific Package (BSP) Layer.
                    Furthermore, the machine customizations should be isolated from
                    recipes and Metadata that support a new GUI environment, for
                    example.
                    This situation gives you a couple of layers: one for the machine
                    configurations, and one for the GUI environment.
                    It is important to understand, however, that the BSP layer can still
                    make machine-specific additions to recipes within
                    the GUI environment layer without polluting the GUI layer itself
                    with those machine-specific changes.
                    You can accomplish this through a recipe that is a BitBake append
                    (<filename>.bbappend</filename>) file, which is described
                    later in this section.
                </para>

                <para>
                    There are certain variable specific to layers, including:
                    <itemizedlist>
                        <listitem><para><filename>LAYERDEPENDS</filename></para></listitem>
                        <listitem><para><filename>LAYERVERSION</filename></para></listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>

        <section id='metadata-classes'>
            <title>Classes</title>

            <para>
                BitBake classes are our rudimentary inheritance mechanism.
                As briefly mentioned in the metadata introduction, they're
                parsed when an inherit directive is encountered, and they
                are located in the <filename>classes/</filename> directory
                relative to the directories in <filename>BBPATH</filename>.
            </para>
        </section>

        <section id='bb-files'>
            <title><filename>.bb</filename> Files</title>

            <para>
                A BitBake (<filename>.bb</filename>) file is a logical unit
                of tasks to be executed.
                Normally this is a package to be built.
                Inter-<filename>.bb</filename> dependencies are obeyed.
                The files themselves are located via the
                <filename>BBFILES</filename> variable, which
                is set to a space separated list of <filename>.bb</filename>
                files, and does handle wildcards.
            </para>
        </section>
    </section>

    <section id='events'>
        <title>Events</title>

        <note>
            This is only supported in <filename>.bb</filename>
            and <filename>.bbclass</filename> files.
        </note>

        <para>
            BitBake allows installation of event handlers.
            Events are triggered at certain points during operation,
            such as the beginning of operation against a given
            <filename>.bb</filename>, the start of a given task,
            task failure, task success, and so forth.
            The intent is to make it easy to do things like email
            notification on build failure.
            <literallayout class='monospaced'>
     addhandler myclass_eventhandler
     python myclass_eventhandler() {
         from bb.event import getName
         from bb import data
         print("The name of the Event is %s" % getName(e))
         print("The file we run for is %s" % data.getVar('FILE', e.data, True))
     }
            </literallayout>
            This event handler gets called every time an event is
            triggered.
            A global variable "<filename>e</filename>" is defined.
            "<filename>e.data</filename>" contains an instance of
            "<filename>bb.data</filename>".
            With the <filename>getName(e)</filename> method one can get
            the name of the triggered event.
        </para>

        <para>
            The above event handler prints the name of the event
            and the content of the <filename>FILE</filename> variable.
            During a Build, the following common events occur:
            <itemizedlist>
                <listitem><para><filename>bb.event.ConfigParsed()</filename></para></listitem>
                <listitem><para><filename>bb.event.ParseStarted()</filename></para></listitem>
                <listitem><para><filename>bb.event.ParseProgress()</filename></para></listitem>
                <listitem><para><filename>bb.event.ParseCompleted()</filename></para></listitem>
                <listitem><para><filename>bb.event.BuildStarted()</filename></para></listitem>
                <listitem><para><filename>bb.build.TaskStarted()</filename></para></listitem>
                <listitem><para><filename>bb.build.TaskInvalid()</filename></para></listitem>
                <listitem><para><filename>bb.build.TaskFailedSilent()</filename></para></listitem>
                <listitem><para><filename>bb.build.TaskFailed()</filename></para></listitem>
                <listitem><para><filename>bb.build.TaskSucceeded()</filename></para></listitem>
                <listitem><para><filename>bb.event.BuildCompleted()</filename></para></listitem>
                <listitem><para><filename>bb.cooker.CookerExit()</filename></para></listitem>
            </itemizedlist>
            Other events that occur based on specific requests to the server:
            <itemizedlist>
                <listitem><para><filename>bb.event.TreeDataPreparationStarted()</filename></para></listitem>
                <listitem><para><filename>bb.event.TreeDataPreparationProgress</filename></para></listitem>
                <listitem><para><filename>bb.event.TreeDataPreparationCompleted</filename></para></listitem>
                <listitem><para><filename>bb.event.DepTreeGenerated</filename></para></listitem>
                <listitem><para><filename>bb.event.CoreBaseFilesFound</filename></para></listitem>
                <listitem><para><filename>bb.event.ConfigFilePathFound</filename></para></listitem>
                <listitem><para><filename>bb.event.FilesMatchingFound</filename></para></listitem>
                <listitem><para><filename>bb.event.ConfigFilesFound</filename></para></listitem>
                <listitem><para><filename>bb.event.TargetsTreeGenerated</filename></para></listitem>
            </itemizedlist>
        </para>
    </section>

    <section id='variants-class-extension-mechanism'>
        <title>Variants - Class Extension Mechanism</title>

        <para>
            Two BitBake features exist to facilitate the creation of
            multiple buildable incarnations from a single recipe file.
        </para>

        <para>
            The first is <filename>BBCLASSEXTEND</filename>.
            This variable is a space separated list of classes used to "extend" the
            recipe for each variant.
            Here is an example that results in a second incarnation of the current
            recipe being available.
            This second incarnation will have the "native" class inherited.
            <literallayout class='monospaced'>
     BBCLASSEXTEND = "native"
            </literallayout>
            The second feature is <filename>BBVERSIONS</filename>.
            This variable allows a single recipe to build multiple versions of a
            project from a single recipe file, and allows you to specify
            conditional metadata (using the <filename>OVERRIDES</filename>
            mechanism) for a single version, or an optionally named range of versions:
            <literallayout class='monospaced'>
     BBVERSIONS = "1.0 2.0 git"
     SRC_URI_git = "git://someurl/somepath.git"
            </literallayout>
            <literallayout class='monospaced'>
     BBVERSIONS = "1.0.[0-6]:1.0.0+ \ 1.0.[7-9]:1.0.7+"
     SRC_URI_append_1.0.7+ = "file://some_patch_which_the_new_versions_need.patch;patch=1"
            </literallayout>
            The name of the range will default to the original version of the
            recipe, so given OE, a recipe file of <filename>foo_1.0.0+.bb</filename>
            will default the name of its versions to <filename>1.0.0+</filename>.
            This is useful, as the range name is not only placed into overrides;
            it's also made available for the metadata to use in the form of the
            <filename>BPV</filename> variable, for use in
            <filename>file://</filename> search paths (<filename>FILESPATH</filename>).
        </para>
    </section>

    <section id='dependencies'>
        <title>Dependencies</title>

        <section id='dependencies-overview'>
            <title>Overview</title>

            <para>
                BitBake handles dependencies at the task level since to
                allow for efficient operation with multiple
                processes executing in parallel, a robust method of
                specifying task dependencies is needed.
            </para>
        </section>

        <section id='dependencies-internal-to-the-bb-file'>
            <title>Dependencies Internal to the <filename>.bb</filename> File</title>

            <para>
                Where the dependencies are internal to a given
                <filename>.bb</filename> file, the dependencies are handled by the
                previously detailed <filename>addtask</filename> directive.
            </para>
        </section>

        <section id='build-dependencies'>
            <title>Build Dependencies</title>

            <para>
                <filename>DEPENDS</filename> lists build time dependencies.
                The 'deptask' flag for tasks is used to signify the task of each
                item listed in <filename>DEPENDS</filename> which must have
                completed before that task can be executed.
                <literallayout class='monospaced'>
     do_configure[deptask] = "do_populate_staging"
                </literallayout>
                In the previous example, the <filename>do_populate_staging</filename>
                task of each item in <filename>DEPENDS</filename> must have completed before
                <filename>do_configure</filename> can execute.
            </para>
        </section>

        <section id='runtime-dependencies'>
            <title>Runtime Dependencies</title>

            <para>
                The <filename>PACKAGES</filename> variable lists runtime
                packages and each of these can have <filename>RDEPENDS</filename> and
                <filename>RRECOMMENDS</filename> runtime dependencies.
                The 'rdeptask' flag for tasks is used to signify the task of each
                item runtime dependency which must have completed before that
                task can be executed.
                <literallayout class='monospaced'>
     do_package_write[rdeptask] = "do_package"
                </literallayout>
                In the previous example, the <filename>do_package</filename>
                task of each item in <filename>RDEPENDS</filename> must have
                completed before <filename>do_package_write</filename> can execute.
            </para>
        </section>

        <section id='recursive-dependencies'>
            <title>Recursive Dependencies</title>

            <para>
                These are specified with the 'recrdeptask' flag
                which is used to signify the task(s) of dependencies
                which must have completed before that task can be
                executed.
                It works by looking though the build
                and runtime dependencies of the current recipe as well
                as any inter-task dependencies the task has,
                then adding a dependency on the listed task.
                It will then recurse through the dependencies of those
                tasks and so on.
            </para>

            <para>
                It may be desirable to recurse not just through the
                dependencies of those tasks but through the
                build and runtime dependencies of dependent tasks too.
                If that is the case, the taskname itself should
                be referenced in the task list (e.g.
                <filename>do_a[recrdeptask] = "do_a do_b"</filename>).
            </para>
        </section>

        <section id='inter-task-dependencies'>
            <title>Inter-Task Dependencies</title>

            <para>
                The 'depends' flag for tasks is a more generic form which
                allows an inter-dependency on specific tasks rather than specifying
                the data in <filename>DEPENDS</filename>.
                <literallayout class='monospaced'>
     do_patch[depends] = "quilt-native:do_populate_staging"
                </literallayout>
                In the previous example, the <filename>do_populate_staging</filename>
                task of the target quilt-native must have completed before the
                <filename>do_patch</filename> task can execute.
            </para>

            <para>
                The 'rdepends' flag works in a similar way but takes targets
                in the runtime namespace instead of the build-time dependency
                namespace.
            </para>
        </section>
    </section>

    <section id='accessing-variables-and-the-data-store-from-python'>
        <title>Accessing Variables and the Data Store from Python</title>

        <para>
            It is often necessary to manipulate variables within python functions
            and the Bitbake data store has an API which allows this.
            The operations available are:
            <literallayout class='monospaced'>
     d.getVar("X", expand=False)
            </literallayout>
            returns the value of variable "X", expanding the value
            if specified.
            <literallayout class='monospaced'>
     d.setVar("X", value)
            </literallayout>
            sets the value of "X" to "value".
            <literallayout class='monospaced'>
     d.appendVar("X", value)
            </literallayout>
            adds "value" to the end of variable X.
            <literallayout class='monospaced'>
     d.prependVar("X", value)
            </literallayout>
            adds "value" to the start of variable X.
            <literallayout class='monospaced'>
     d.delVar("X")
            </literallayout>
            deletes the variable X from the data store.
            <literallayout class='monospaced'>
     d.renameVar("X", "Y")
            </literallayout>
            renames variable X to Y.
            <literallayout class='monospaced'>
     d.getVarFlag("X", flag, expand=False)
            </literallayout>
            gets given flag from variable X but does not expand it.
            <literallayout class='monospaced'>
     d.setVarFlag("X", flag, value)
            </literallayout>
            sets given flag for variable X to value.
            <filename>setVarFlags</filename> will not clear previous flags.
            Think of this method as <filename>addVarFlags</filename>.
            <literallayout class='monospaced'>
     d.appendVarFlag("X", flag, value)
            </literallayout>
            Need description.
            <literallayout class='monospaced'>
     d.prependVarFlag("X", flag, value)
            </literallayout>
            Need description.
            <literallayout class='monospaced'>
     d.delVarFlag("X", flag)
            </literallayout>
            Need description.
            <literallayout class='monospaced'>
     d.setVarFlags("X", flagsdict)
            </literallayout>
            sets the flags specified in the <filename>dict()</filename> parameter.
            <literallayout class='monospaced'>
     d.getVarFlags("X")
            </literallayout>
            returns a <filename>dict</filename> of the flags for X.
            <literallayout class='monospaced'>
     d.delVarFlags
            </literallayout>
            deletes all the flags for a variable.
        </para>
    </section>

    <section id='task-checksums-and-setscene'>
        <title>Task Checksums and Setscene</title>

        <para>
            This list is a place holder of content that needs explanation here.
            Items should be moved to appropriate sections below as completed.
            <itemizedlist>
                <listitem><para><filename>STAMP</filename></para></listitem>
                <listitem><para><filename>STAMPCLEAN</filename></para></listitem>
                <listitem><para><filename>BB_STAMP_WHITELIST</filename></para></listitem>
                <listitem><para><filename>BB_STAMP_POLICY</filename></para></listitem>
                <listitem><para><filename>BB_HASHCHECK_FUNCTION</filename></para></listitem>
                <listitem><para><filename>BB_SETSCENE_VERIFY_FUNCTION</filename></para></listitem>
                <listitem><para><filename>BB_SETSCENE_DEPVALID</filename></para></listitem>
                <listitem><para><filename>BB_TASKHASH</filename></para></listitem>
            </itemizedlist>
        </para>

        <section id='checksums'>
            <title>Checksums (Signatures)</title>

            <para>
                BitBake uses checksums (or signatures) along with the setscene
                to determine if a task needs to be run.
                This section describes the process.
                To help understand how BitBake does this, the section assumes an
                OpenEmbedded metadata-based example.
            </para>

            <para>
                The setscene code uses a checksum, which is a unique signature of a task's
                inputs, to determine if a task needs to be run again.
                Because it is a change in a task's inputs that triggers a rerun, the process
                needs to detect all the inputs to a given task.
                For shell tasks, this turns out to be fairly easy because
                BitBake generates a "run" shell script for each task and
                it is possible to create a checksum that gives you a good idea of when
                the task's data changes.
            </para>

            <para>
                To complicate the problem, some things should not be included in
                the checksum.
                First, there is the actual specific build path of a given task -
                the working directory.
                It does not matter if the work directory changes because it should not
                affect the output for target packages.
                The simplistic approach for excluding the work directory is to set
                it to some fixed value and create the checksum for the "run" script.
            </para>

            <para>
                Another problem results from the "run" scripts containing functions that
                might or might not get called.
                The incremental build solution contains code that figures out dependencies
                between shell functions.
                This code is used to prune the "run" scripts down to the minimum set,
                thereby alleviating this problem and making the "run" scripts much more
                readable as a bonus.
            </para>

            <para>
                So far we have solutions for shell scripts.
                What about Python tasks?
                The same approach applies even though these tasks are more difficult.
                The process needs to figure out what variables a Python function accesses
                and what functions it calls.
                Again, the incremental build solution contains code that first figures out
                the variable and function dependencies, and then creates a checksum for the data
                used as the input to the task.
            </para>

            <para>
                Like the working directory case, situations exist where dependencies
                should be ignored.
                For these cases, you can instruct the build process to ignore a dependency
                by using a line like the following:
                <literallayout class='monospaced'>
     PACKAGE_ARCHS[vardepsexclude] = "MACHINE"
                </literallayout>
                This example ensures that the <filename>PACKAGE_ARCHS</filename> variable does not
                depend on the value of <filename>MACHINE</filename>, even if it does reference it.
            </para>

            <para>
                Equally, there are cases where we need to add dependencies BitBake
                is not able to find.
                You can accomplish this by using a line like the following:
                <literallayout class='monospaced'>
      PACKAGE_ARCHS[vardeps] = "MACHINE"
                </literallayout>
                This example explicitly adds the <filename>MACHINE</filename> variable as a
                dependency for <filename>PACKAGE_ARCHS</filename>.
            </para>

            <para>
                Consider a case with in-line Python, for example, where BitBake is not
                able to figure out dependencies.
                When running in debug mode (i.e. using <filename>-DDD</filename>), BitBake
                produces output when it discovers something for which it cannot figure out
                dependencies.
            </para>

            <para>
                Thus far, this section has limited discussion to the direct inputs into a task.
                Information based on direct inputs is referred to as the "basehash" in the
                code.
                However, there is still the question of a task's indirect inputs - the
                things that were already built and present in the build directory.
                The checksum (or signature) for a particular task needs to add the hashes
                of all the tasks on which the particular task depends.
                Choosing which dependencies to add is a policy decision.
                However, the effect is to generate a master checksum that combines the basehash
                and the hashes of the task's dependencies.
            </para>

            <para>
                At the code level, there are a variety of ways both the basehash and the
                dependent task hashes can be influenced.
                Within the BitBake configuration file, we can give BitBake some extra information
                to help it construct the basehash.
                The following statement effectively results in a list of global variable
                dependency excludes - variables never included in any checksum.
                This example uses variables from OpenEmbedded to help illustrate
                the concept:
                <literallayout class='monospaced'>
     BB_HASHBASE_WHITELIST ?= "TMPDIR FILE PATH PWD BB_TASKHASH BBPATH DL_DIR \
         SSTATE_DIR THISDIR FILESEXTRAPATHS FILE_DIRNAME HOME LOGNAME SHELL TERM \
         USER FILESPATH STAGING_DIR_HOST STAGING_DIR_TARGET COREBASE PRSERV_HOST \
         PRSERV_DUMPDIR PRSERV_DUMPFILE PRSERV_LOCKDOWN PARALLEL_MAKE \
         CCACHE_DIR EXTERNAL_TOOLCHAIN CCACHE CCACHE_DISABLE LICENSE_PATH SDKPKGSUFFIX"
                </literallayout>
                The previous example excludes the work directory, which is part of
                <filename>TMPDIR</filename>.
            </para>

            <para>
                The rules for deciding which hashes of dependent tasks to include through
                dependency chains are more complex and are generally accomplished with a
                Python function.
                The code in <filename>meta/lib/oe/sstatesig.py</filename> shows two examples
                of this and also illustrates how you can insert your own policy into the system
                if so desired.
                This file defines the two basic signature generators OpenEmbedded Core
                uses:  "OEBasic" and "OEBasicHash".
                By default, there is a dummy "noop" signature handler enabled in BitBake.
                This means that behavior is unchanged from previous versions.
                <filename>OE-Core</filename> uses the "OEBasicHash" signature handler by default
                through this setting in the <filename>bitbake.conf</filename> file:
                <literallayout class='monospaced'>
     BB_SIGNATURE_HANDLER ?= "OEBasicHash"
                </literallayout>
                The "OEBasicHash" <filename>BB_SIGNATURE_HANDLER</filename> is the same as the
                "OEBasic" version but adds the task hash to the stamp files.
                This results in any metadata change that changes the task hash, automatically
                causing the task to be run again.
                This removes the need to bump
                <link linkend='var-PR'><filename>PR</filename></link>
                values, and changes to metadata automatically ripple across the build.
            </para>

            <para>
                It is also worth noting that the end result of these signature generators is to
                make some dependency and hash information available to the build.
                This information includes:
                <itemizedlist>
                    <listitem><para><filename>BB_BASEHASH_task-&lt;taskname&gt;</filename>:
                        The base hashes for each task in the recipe.
                        </para></listitem>
                    <listitem><para><filename>BB_BASEHASH_&lt;filename:taskname&gt;</filename>:
                        The base hashes for each dependent task.
                        </para></listitem>
                    <listitem><para><filename>BBHASHDEPS_&lt;filename:taskname&gt;</filename>:
                        The task dependencies for each task.
                        </para></listitem>
                    <listitem><para><filename>BB_TASKHASH</filename>:
                        The hash of the currently running task.
                        </para></listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
</chapter>
