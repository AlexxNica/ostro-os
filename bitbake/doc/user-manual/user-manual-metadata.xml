<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter id="user-manual-metadata">
    <title>Metadata</title>

    <section>
            <title>Description</title>
            <itemizedlist>
                <para>BitBake metadata can be classified into 3 major areas:</para>
                <listitem>
                    <para>Configuration Files</para>
                </listitem>
                <listitem>
                    <para>.bb Files</para>
                </listitem>
                <listitem>
                    <para>Classes</para>
                </listitem>
            </itemizedlist>
        <para>
            What follows are a large number of examples of BitBake metadata.  Any syntax which isn't supported
            in any of the aforementioned areas will be documented as such.
        </para>
    </section>

    <section id='basic-syntax'>
        <title>Basic Syntax</title>

        <section id='basic-variable-setting'>
            <title>Basic variable setting</title>

            <para>
                <literallayout class='monospaced'>
     VARIABLE = "value"
                </literallayout>
                In this example, <filename>VARIABLE</filename> is <filename>value</filename>.
            </para>
        </section>

        <section id='variable-expansion'>
            <title>Variable expansion</title>

            <para>
                BitBake supports variables referencing one another's
                contents using a syntax which is similar to shell
                scripting
            </para>

            <para>
                <literallayout class='monospaced'>
     A = "aval"
     B = "pre${A}post"
                </literallayout>
                This results in <filename>A</filename> containing
                <filename>aval</filename> and <filename>B</filename> containing
                <filename>preavalpost</filename>.
            </para>
        </section>

        <section id='setting-a-default-value'>
            <title>Setting a default value (?=)</title>

            <para>
                <literallayout class='monospaced'>
     A ?= "aval"
                </literallayout>
                If <filename>A</filename> is set before the above is called,
                it will retain its previous value.
                If <filename>A</filename> is unset prior to the above call,
                <filename>A</filename> will be set to <filename>aval</filename>.
                    Note that this assignment is immediate, so if there are multiple ?= assignments
                    to a single variable, the first of those will be used.
            </para>
        </section>

        <section id='setting-a-weak-default-value'>
            <title>Setting a weak default value (??=)</title>

            <para>
                <literallayout class='monospaced'>
     A ??= "somevalue"
     A ??= "someothervalue"
                </literallayout>
                If <filename>A</filename> is set before the above,
                it will retain that value.
                If <filename>A</filename> is unset prior to the above,
                <filename>A</filename> will be set to <filename>someothervalue</filename>.
                This is a lazy/weak assignment in that the assignment does not occur until the end
                of the parsing process, so that the last, rather than the first,
                ??= assignment to a given variable will be used.
                Any other setting of <filename>A</filename> using = or ?=
                will however override the value set with ??=
            </para>
        </section>

        <section id='immediate-variable-expansion'>
            <title>Immediate variable expansion (:=)</title>

            <para>
                := results in a variable's contents being expanded immediately, rather than when the variable is actually used.
            <literallayout class='monospaced'>
     T = "123"
     A := "${B} ${A} test ${T}"
     T = "456"
     B = "${T} bval"
     C = "cval"
     C := "${C}append"
                </literallayout>
                In that example, <filename>A</filename> would contain
                <filename>test 123</filename>, <filename>B</filename> would contain
                <filename>456 bval</filename>, and <filename>C</filename>
                would be <filename>cvalappend</filename>.
            </para>
        </section>

        <section id='appending-and-prepending'>
            <title>Appending (+=) and prepending (=+)</title>

            <para>
                <literallayout class='monospaced'>
     B = "bval"
     B += "additionaldata"
     C = "cval"
     C =+ "test"
                </literallayout>
                In this example, <filename>B</filename> is now
                <filename>bval additionaldata</filename> and <filename>C</filename>
                is <filename>test cval</filename>.
            </para>
        </section>

        <section id='appending-and-prepending-without-spaces'>
            <title>Appending (.=) and prepending (=.) without spaces</title>

            <para>
                <literallayout class='monospaced'>
     B = "bval"
     B .= "additionaldata"
     C = "cval"
     C =. "test"
                </literallayout>
                In this example, <filename>B</filename> is now
                <filename>bvaladditionaldata</filename> and
                <filename>C</filename> is <filename>testcval</filename>.
                In contrast to the above appending and prepending operators,
                no additional space will be introduced.
            </para>
        </section>

        <section id='appending-and-prepending-override-style-syntax'>
            <title>Appending and Prepending (override style syntax)</title>

            <para>
                <literallayout class='monospaced'>
     B = "bval"
     B_append = " additional data"
     C = "cval"
     C_prepend = "additional data "
                </literallayout>
                This example results in <filename>B</filename>
                becoming <filename>bval additional data</filename>
                and <filename>C</filename> becoming
                <filename>additional data cval</filename>.
                    Note the spaces in the <filename>_append</filename>.
                    Unlike the += operator, additional space is not automatically added.
                    You must take steps to add space
yourself.
            </para>
        </section>

        <section id='removing-override-style-syntax'>
            <title>Removing (override style syntax)</title>
            <para>
                <literallayout class='monospaced'>
     FOO = "123 456 789 123456 123 456 123 456"
     FOO_remove = "123"
     FOO_remove = "456"
                </literallayout>
                In this example, <filename>FOO</filename> is now <filename>789 123456</filename>.
            </para>
        </section>

        <section id='variable-flags'>
            <title>Variable flags</title>

            <para>
                Variables can have associated flags which provide a way of tagging extra information onto a variable.
                Several flags are used internally by BitBake but they can be used externally too if needed.
                The standard operations mentioned above also work on flags.
                <literallayout class='monospaced'>
     VARIABLE[SOMEFLAG] = "value"
                </literallayout>
                In this example, <filename>VARIABLE</filename> has a flag,
                <filename>SOMEFLAG</filename> which is set to <filename>value</filename>.
            </para>
        </section>

        <section id='inline-python-variable-expansion'>
            <title>Python variable expansion</title>

            <para>
                <literallayout class='monospaced'>
     DATE = "${@time.strftime('%Y%m%d',time.gmtime())}"
                </literallayout>
                This would result in the <filename>DATE</filename>
                variable containing today's date.
            </para>
        </section>

    <section id='conditional-syntax-overrides'>
        <title>Conditional metadata set</title>

            <para>
                <filename>OVERRIDES</filename> is a <quote>:</quote> separated variable containing
                each item you want to satisfy conditions.
                So, if you have a variable which is conditional on <quote>arm</quote>, and <quote>arm</quote>
                is in <filename>OVERRIDES</filename>, then the <quote>arm</quote> specific
                version of the variable is used rather than the non-conditional
                version.
                Example:
                <literallayout class='monospaced'>
     OVERRIDES = "architecture:os:machine"
     TEST = "defaultvalue"
     TEST_os = "osspecificvalue"
     TEST_condnotinoverrides = "othercondvalue"
                </literallayout>
                In this example, <filename>TEST</filename> would be
                <filename>osspecificvalue</filename>, due to the condition
                <quote>os</quote> being in <filename>OVERRIDES</filename>.
            </para>
        </section>

        <section id='conditional-appending'>
            <title>Conditional appending</title>

            <para>
                BitBake also supports appending and prepending to variables based
                on whether something is in <filename>OVERRIDES</filename>.  Example:
                <literallayout class='monospaced'>
     DEPENDS = "glibc ncurses"
     OVERRIDES = "machine:local"
     DEPENDS_append_machine = "libmad"
                </literallayout>
                In this example, <filename>DEPENDS</filename> is set to
                "glibc ncurses libmad".
            </para>
        </section>

        <section id='variable-interaction-worked-examples'>
            <title>Variable interaction: Worked Examples</title>

            <para>
                Despite the documentation of the different forms of
                variable definition above, it can be hard to work
                out what happens when variable operators are combined.
                This section documents some common questions people have
                regarding the way variables interact.
            </para>

            <para>
                There is often confusion about which order overrides and the
                various append operators take effect.
            </para>

            <para>
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A_foo_append = "X"
                </literallayout>
                In this case, <filename>X</filename> is unconditionally appended
                to the variable <filename>A_foo</filename>.
                Since foo is an override, <filename>A_foo</filename> would then replace
                <filename>A</filename>.
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A = "X"
     A_append_foo = "Y"
                </literallayout>
                In this case, only when <filename>foo</filename> is in
                <filename>OVERRIDES</filename>, <filename>Y</filename>
                is appended to the variable <filename>A</filename>
                so the value of <filename>A</filename> would
                become <filename>XY</filename> (NB: no spaces are appended).
                <literallayout class='monospaced'>
     OVERRIDES = "foo"
     A_foo_append = "X"
     A_foo_append += "Y"
                </literallayout>
                This behaves as per the first case above, but the value of
                <filename>A</filename> would be "X Y" instead of just "X".
                <literallayout class='monospaced'>
     A = "1"
     A_append = "2"
     A_append = "3"
     A += "4"
     A .= "5"
                </literallayout>
                Would ultimately result in <filename>A</filename> taking the value
                "1 4523" since the _append operator executes at the
                same time as the expansion of other overrides.
            </para>
        </section>

        <section id='key-expansion'>
            <title>Key Expansion</title>

            <para>
                Key expansion happens at the data store finalisation
                time just before overrides are expanded.
                <literallayout class='monospaced'>
     A${B} = "X"
     B = "2"
     A2 = "Y"
                </literallayout>
                So in this case <filename>A2</filename> would take the value of "X".
            </para>
        </section>
    </section>

    <section id='inheritance'>
        <title>Inheritance</title>

        <section id='inheritance-directive'>
            <title>Inheritance</title>
            <para><emphasis>NOTE:</emphasis>
                This is only supported in .bb and .bbclass files.
            </para>
            <para>
                The inherit directive is a means of specifying what classes
                of functionality your <filename>.bb</filename> requires.
                It is a rudimentary form of inheritance.
                For example, you can easily abstract out the tasks involved in
                building a package that uses autoconf and automake, and put
                that into a bbclass for your packages to make use of.
                A given bbclass is located by searching for classes/filename.bbclass
                in <filename>BBPATH</filename>, where filename is what you inherited.
            </para>
        </section>

        <section id='inclusion-directive'>
            <title>Inclusion</title>

            <para>
                Next, there is the <filename>include</filename> directive, which causes BitBake to parse whatever file you specify,
                and insert it at that location, which is not unlike <command>make</command>.
                However, if the path specified on the <filename>include</filename> line is a
                relative path, BitBake will locate the first one it can find
                within <filename>BBPATH</filename>.
            </para>
        </section>

        <section id='requiring-inclusion'>
            <title>Requiring inclusion</title>
            <para>
                In contrast to the <filename>include</filename> directive, <filename>require</filename> will
raise an
                ParseError if the file to be included cannot
                be found.
                Otherwise it will behave just like the <filename>include</filename> directive.
            </para>
        </section>

    </section>

    <section id='defining-python-functions-into-the-global-python-namespace'>
        <title>Defining Python functions into the global Python namespace</title>

        <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files
                <literallayout class='monospaced'>
     def get_depends(d):
         if d.getVar('SOMECONDITION', True):
             return "dependencywithcond"
         else:
             return "dependency"
     SOMECONDITION = "1"
     DEPENDS = "${@get_depends(d)}"
                </literallayout>
                This would result in <filename>DEPENDS</filename> containing <filename>dependencywithcond</filename>.
            </para>
    </section>

    <section>
        <title>Defining executable metadata</title>
            <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.
            <literallayout class='monospaced'>
do_mytask () {
    echo "Hello, world!"
}
            </literallayout>
            This is essentially identical to setting a variable, except that this variable happens to be executable shell code.
            <literallayout class='monospaced'>
python do_printdate () {
    import time
    print time.strftime('%Y%m%d', time.gmtime())
}
            </literallayout>
            This is the similar to the previous, but flags it as Python so that BitBake knows it is Python code.
        </para>
    </section>

    <section>
        <title>Tasks</title>
        <para><emphasis>NOTE:</emphasis> This is only supported in .bb and .bbclass files.</para>
        <para>In BitBake, each step that needs to be run for a given .bb is known as a task.  There is a command <filename>addtask</filename> to add new tasks (must be a defined Python executable metadata and must start with <quote>do_</quote>) and describe intertask dependencies.
            <literallayout class='monospaced'>
     python do_printdate () {
         import time print
         time.strftime('%Y%m%d', time.gmtime())
     }
     addtask printdate after do_fetch before do_build
            </literallayout>
            This defines the necessary Python function and adds it as a task which is now a dependency of do_build, the default task.  If anyone executes the do_build task, that will result in do_printdate being run first.
        </para>
    </section>

    <section id='task-flags'>
        <title>Task Flags</title>

        <para>
            Tasks support a number of flags which control various
            functionality of the task. These are as follows:
        </para>
                <para>'dirs' - directories which should be created before the task runs</para>
                <para>'cleandirs' - directories which should be created before the task runs but should be empty</para>
                <para>'noexec' - marks the tasks as being empty and no execution required. These are used as dependency placeholders or used when added tasks need to be subsequently disabled.</para>
                <para>'nostamp' - don't generate a stamp file for a task. This means the task is always rexecuted.</para>
                <para>'fakeroot' - this task needs to be run in a fakeroot environment, obtained by adding the variables in FAKEROOTENV to the environment.</para>
                <para>'umask' - the umask to run the task under.</para>
                <para> For the 'deptask', 'rdeptask', 'depends', 'rdepends' and 'recrdeptask' flags please see the dependencies section.</para>
        </section>

        <section id='parsing-overview'>
            <title>Parsing</title>
        <section id='configiguration-files'>
            <title>Configuration files</title>
            <para>
                The first kind of metadata in BitBake is configuration metadata.
                This metadata is global, and therefore affects <emphasis>all</emphasis> packages and
                tasks which are executed.
            </para>

            <para>
                BitBake will first search the current working directory for an
                optional <filename>conf/bblayers.conf</filename> configuration file.
                This file is expected to contain a <filename>BBLAYERS</filename>
                variable which is a space delimited list of 'layer' directories.
                For each directory in this list, a <filename>conf/layer.conf</filename>
                file will be searched for and parsed with the
                <filename>LAYERDIR</filename> variable being set to the directory where
                the layer was found.
                The idea is these files will setup <filename>BBPATH</filename>
                and other variables correctly for a given build directory automatically
                for the user.
            </para>

            <para>
                BitBake will then expect to find <filename>conf/bitbake.conf</filename>
                somewhere in the user specified <filename>BBPATH</filename>.
                That configuration file generally has include directives to pull
                in any other metadata (generally files specific to architecture,
                machine, <emphasis>local</emphasis> and so on).
            </para>

            <para>
                Only variable definitions and include directives are allowed
                in <filename>.conf</filename> files.
            </para>
        </section>
        <section id='classes'>
            <title>Classes</title>
            <para>
                BitBake classes are our rudimentary inheritance mechanism.
                As briefly mentioned in the metadata introduction, they're
                parsed when an inherit directive is encountered, and they
                are located in the <filename>classes/</filename> directory
                relative to the directories in <filename>BBPATH</filename>.
            </para>
        </section>

        <section id='bb-files'>
            <title>.<filename>.bb</filename> files</title>

            <para>
                BitBake (<filename>.bb</filename>) file is a logical unit
                of tasks to be executed.
                Normally this is a package to be built.
                Inter-<filename>.bb</filename> dependencies are obeyed.
                The files themselves are located via
                the <filename>BBFILES</filename> variable, which
                is set to a space separated list of <filename>.bb</filename>
                files, and does handle wildcards.
            </para>
        </section>
    </section>

    <section id='events'>
        <title>Events</title>

        <para>
            <emphasis>NOTE:</emphasis>
            This is only supported in <filename>.bb</filename> 
            and <filename>.bbclass</filename> files.
        </para>
        <para>
            BitBake allows installation of event handlers.
            Events are triggered at certain points during operation,
            such as the beginning of operation against a given
            <filename>.bb</filename>, the start of a given task,
            task failure, task success, et cetera.
            The intent is to make it easy to do things like email
            notification on build failure.
            <literallayout class='monospaced'>
     addhandler myclass_eventhandler
     python myclass_eventhandler() {
         from bb.event import getName
         from bb import data
         print("The name of the Event is %s" % getName(e))
         print("The file we run for is %s" % data.getVar('FILE', e.data, True))
     }
            </literallayout>
            This event handler gets called every time an event is
            triggered.
            A global variable <filename>e</filename> is defined.
            <filename>e.data</filename> contains an instance of
            <filename>bb.data</filename>.
            With the <filename>getName(e)</filename> method one can get
            the name of the triggered event.
        </para>

        <para>
            The above event handler prints the name of the event
            and the content of the <filename>FILE</filename> variable.
        </para>
    </section>

    <section id='variants-class-extension-mechanism'>
        <title>Variants</title>

        <para>
            Two BitBake features exist to facilitate the creation of
            multiple buildable incarnations from a single recipe file.
        </para>

        <para>
            The first is <filename>BBCLASSEXTEND</filename>.
            This variable is a space separated list of classes used to "extend" the
            recipe for each variant.
            As an example, setting
            <literallayout class='monospaced'>
     BBCLASSEXTEND = "native"
            </literallayout>
            results in a second incarnation of the current
            recipe being available.
            This second incarnation will have the "native" class inherited.
        </para>
        <para>
            The second feature is <filename>BBVERSIONS</filename>.
            This variable allows a single recipe to build multiple versions of a
            project from a single recipe file, and allows you to specify
            conditional metadata (using the <filename>OVERRIDES</filename>
            mechanism) for a single version, or an optionally named range of versions:
            <literallayout class='monospaced'>
     BBVERSIONS = "1.0 2.0 git"
     SRC_URI_git = "git://someurl/somepath.git"
            </literallayout>
            <literallayout class='monospaced'>
     BBVERSIONS = "1.0.[0-6]:1.0.0+ \ 1.0.[7-9]:1.0.7+"
     SRC_URI_append_1.0.7+ = "file://some_patch_which_the_new_versions_need.patch;patch=1"
            </literallayout>
            Note that the name of the range will default to the original version of the
            recipe, so given OE, a recipe file of <filename>foo_1.0.0+.bb</filename>
            will default the name of its versions to <filename>1.0.0+</filename>.
            This is useful, as the range name is not only placed into overrides;
            it's also made available for the metadata to use in the form of the
            <filename>BPV</filename> variable, for use in
            <filename>file://</filename> search paths (<filename>FILESPATH</filename>).
        </para>
    </section>

    <section id='dependencies'>
        <title>Dependency handling</title>

            <para>
                BitBake handles dependencies at the task level since to
                allow for efficient operation with multiple
                processed executing in parallel. A robust method of
                specifying task dependencies is therefore needed.
            </para>

        <section id='dependencies-internal-to-the-bb-file'>
            <title>Dependencies internal to the <filename>.bb</filename> file</title>

            <para>
                Where the dependencies are internal to a given
                <filename>.bb</filename> file, the dependencies are handled by the
                previously detailed <filename>addtask</filename> directive.
            </para>
        </section>

        <section id='build-dependencies'>
            <title>Build Dependencies</title>

            <para>
                <filename>DEPENDS</filename> lists build time dependencies.
                The 'deptask' flag for tasks is used to signify the task of each
                item listed in <filename>DEPENDS</filename> which must have
                completed before that task can be executed.
                <literallayout class='monospaced'>
     do_configure[deptask] = "do_populate_staging"
                </literallayout>
                means the <filename>do_populate_staging</filename>
                task of each item in <filename>DEPENDS</filename> must have completed before
                <filename>do_configure</filename> can execute.
            </para>
        </section>

        <section id='runtime-dependencies'>
            <title>Runtime Dependencies</title>

            <para>
                The <filename>PACKAGES</filename> variable lists runtime
                packages and each of these can have <filename>RDEPENDS</filename> and
                <filename>RRECOMMENDS</filename> runtime dependencies.
                The 'rdeptask' flag for tasks is used to signify the task of each
                item runtime dependency which must have completed before that
                task can be executed.
                <literallayout class='monospaced'>
     do_package_write[rdeptask] = "do_package"
                </literallayout>
                means the <filename>do_package</filename>
                task of each item in <filename>RDEPENDS</filename> must have
                completed before <filename>do_package_write</filename> can execute.
            </para>
        </section>

        <section id='recursive-dependencies'>
            <title>Recursive Dependencies</title>

            <para>
                These are specified with the 'recrdeptask' flag
                which is used signify the task(s) of dependencies
                which must have completed before that task can be
                executed.
                It works by looking though the build
                and runtime dependencies of the current recipe as well
                as any inter-task dependencies the task has,
                then adding a dependency on the listed task.
                It will then recurse through the dependencies of those
                tasks and so on.
            </para>

            <para>
                It may be desireable to recurse not just through the
                dependencies of those tasks but through the
                build and runtime dependencies of dependent tasks too.
                If that is the case, the taskname itself should
                be referenced in the task list, e.g.
                <filename>do_a[recrdeptask] = "do_a do_b"</filename>.
            </para>
        </section>

        <section id='inter-task-dependencies'>
            <title>Inter task</title>

            <para>
                The 'depends' flag for tasks is a more generic form of which
                allows an interdependency on specific tasks rather than specifying
                the data in <filename>DEPENDS</filename>.
                <literallayout class='monospaced'>
     do_patch[depends] = "quilt-native:do_populate_staging"
                </literallayout>
                means the <filename>do_populate_staging</filename>
                task of the target quilt-native must have completed before the
                <filename>do_patch</filename> task can execute.
            </para>

            <para>
                The 'rdepends' flag works in a similar way but takes targets
                in the runtime namespace instead of the build time dependency
                namespace.
            </para>
        </section>
    </section>
</chapter>
