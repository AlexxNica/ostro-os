From 38ea0bd1d5d999a152a4e7f199492c4222e0149f Mon Sep 17 00:00:00 2001
From: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date: Wed, 29 Oct 2014 00:26:14 +0200
Subject: [PATCH 17/45] ima: limit capabilities for unsigned executables

This patch provides functionality to limit capabilities for unsigned
executables. Capabilities are raised from the security.capability
extended attribute which is protected by EVM. Capabilities are not
dropped if a file has EVM signature.

Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
---
 security/integrity/ima/ima.h          |  41 ++++++++++--
 security/integrity/ima/ima_api.c      |   5 +-
 security/integrity/ima/ima_appraise.c |   2 +-
 security/integrity/ima/ima_main.c     |  31 ++++++++-
 security/integrity/ima/ima_policy.c   | 120 +++++++++++++++++++++++++++-------
 security/integrity/integrity.h        |   2 +
 6 files changed, 165 insertions(+), 36 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index dbcf91e..6372a14 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -128,8 +128,40 @@ static inline unsigned long ima_hash_key(u8 *digest)
 	return hash_long(*digest, IMA_HASH_BITS);
 }
 
+/* IMA policy related functions */
+enum ima_hooks { FILE_CHECK = 1, MMAP_CHECK, BPRM_CHECK, MODULE_CHECK,
+		 FIRMWARE_CHECK, POLICY_CHECK, POST_SETATTR };
+
+#define MAX_LSM_RULES 6
+enum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,
+	LSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE
+};
+
+struct ima_rule_entry {
+	struct list_head list;
+	int action;
+	unsigned int flags;
+	enum ima_hooks func;
+	int mask;
+	unsigned long fsmagic;
+	u8 fsuuid[16];
+	kuid_t uid;
+	kuid_t fowner;
+	kernel_cap_t cap_permitted;
+	struct {
+		void *rule;	/* LSM file metadata specific */
+		void *args_p;	/* audit value */
+		int type;	/* audit type */
+	} lsm[MAX_LSM_RULES];
+};
+
+struct ima_action_context {
+	struct ima_rule_entry *appraise;
+};
+
 /* LIM API function definitions */
-int ima_get_action(struct inode *inode, int mask, int function);
+int ima_get_action(struct inode *inode, int mask, int function,
+		   struct ima_action_context *ctx);
 int ima_must_measure(struct inode *inode, int mask, int function);
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file, enum hash_algo algo);
@@ -148,12 +180,8 @@ int ima_store_template(struct ima_template_entry *entry, int violation,
 void ima_free_template_entry(struct ima_template_entry *entry);
 const char *ima_d_path(struct path *path, char **pathbuf);
 
-/* IMA policy related functions */
-enum ima_hooks { FILE_CHECK = 1, MMAP_CHECK, BPRM_CHECK, MODULE_CHECK,
-		 FIRMWARE_CHECK, POLICY_CHECK, POST_SETATTR };
-
 int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,
-		     int flags);
+		     int flags, struct ima_action_context *ctx);
 void ima_init_policy(void);
 void ima_update_policy(void);
 void ima_update_policy_flag(void);
@@ -166,6 +194,7 @@ void ima_delete_rules(void);
 #define IMA_APPRAISE_LOG	0x04
 #define IMA_APPRAISE_MODULES	0x08
 #define IMA_APPRAISE_FIRMWARE	0x10
+#define IMA_APPRAISE_DROP_CAPS	0x20
 
 #ifdef CONFIG_IMA_APPRAISE
 int ima_appraise_measurement(int func, struct integrity_iint_cache *iint,
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 8eb6a0a..e96b41e 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -169,13 +169,14 @@ err_out:
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
  *
  */
-int ima_get_action(struct inode *inode, int mask, int function)
+int ima_get_action(struct inode *inode, int mask, int function,
+		   struct ima_action_context *ctx)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
 
 	flags &= ima_policy_flag;
 
-	return ima_match_policy(inode, function, mask, flags);
+	return ima_match_policy(inode, function, mask, flags, ctx);
 }
 
 /*
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 4605530..dc52cc2 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -41,7 +41,7 @@ int ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)
 	if (!ima_appraise)
 		return 0;
 
-	return ima_match_policy(inode, func, mask, IMA_APPRAISE);
+	return ima_match_policy(inode, func, mask, IMA_APPRAISE, NULL);
 }
 
 static int ima_fix_xattr(struct dentry *dentry,
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 7b0c0fb..4d064c8 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -168,6 +168,7 @@ static int process_measurement(struct file *file, int mask, int function,
 	int xattr_len = 0;
 	bool violation_check;
 	enum hash_algo hash_algo;
+	struct ima_action_context ctx;
 
 	if (!ima_policy_flag || !S_ISREG(inode->i_mode))
 		return 0;
@@ -176,7 +177,7 @@ static int process_measurement(struct file *file, int mask, int function,
 	 * bitmask based on the appraise/audit/measurement policy.
 	 * Included is the appraise submask.
 	 */
-	action = ima_get_action(inode, mask, function);
+	action = ima_get_action(inode, mask, function, &ctx);
 	violation_check = ((function == FILE_CHECK || function == MMAP_CHECK) &&
 			   (ima_policy_flag & IMA_MEASURE));
 	if (!action && !violation_check)
@@ -277,6 +278,8 @@ out:
 	if (pathbuf)
 		__putname(pathbuf);
 	if (must_appraise) {
+		if (iint->flags & IMA_DROP_CAPS)
+			iint->cap_permitted = ctx.appraise->cap_permitted;
 		if (rc && (ima_appraise & IMA_APPRAISE_ENFORCE))
 			return -EACCES;
 		if (file->f_mode & FMODE_WRITE)
@@ -303,6 +306,25 @@ int ima_file_mmap(struct file *file, unsigned long prot)
 	return 0;
 }
 
+static void ima_drop_caps(struct linux_binprm *bprm)
+{
+	struct inode *inode = file_inode(bprm->file);
+	struct integrity_iint_cache *iint;
+	struct cred *cred = bprm->cred;
+
+	iint = integrity_iint_find(inode);
+	if (!iint)
+		return;
+
+	if (test_bit(EVM_DIGSIG, &iint->atomic_flags))
+		return; /* don't drop */
+
+	if (iint->flags & IMA_DROP_CAPS)
+		cred->cap_effective = cap_intersect(cred->cap_effective,
+						    iint->cap_permitted);
+}
+
+
 /**
  * ima_bprm_check - based on policy, collect/store measurement.
  * @bprm: contains the linux_binprm structure
@@ -318,7 +340,12 @@ int ima_file_mmap(struct file *file, unsigned long prot)
  */
 int ima_bprm_check(struct linux_binprm *bprm)
 {
-	return process_measurement(bprm->file, MAY_EXEC, BPRM_CHECK, 0);
+	int rc;
+
+	rc = process_measurement(bprm->file, MAY_EXEC, BPRM_CHECK, 0);
+	if (!rc && (ima_appraise & IMA_APPRAISE_DROP_CAPS))
+		ima_drop_caps(bprm);
+	return rc;
 }
 
 /**
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 6d5de0c..a309938 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -37,28 +37,6 @@
 
 int ima_policy_flag;
 
-#define MAX_LSM_RULES 6
-enum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,
-	LSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE
-};
-
-struct ima_rule_entry {
-	struct list_head list;
-	int action;
-	unsigned int flags;
-	enum ima_hooks func;
-	int mask;
-	unsigned long fsmagic;
-	u8 fsuuid[16];
-	kuid_t uid;
-	kuid_t fowner;
-	struct {
-		void *rule;	/* LSM file metadata specific */
-		void *args_p;	/* audit value */
-		int type;	/* audit type */
-	} lsm[MAX_LSM_RULES];
-};
-
 /*
  * Without LSM specific knowledge, the default policy can only be
  * written in terms of .action, .func, .mask, .fsmagic, .uid, and .fowner
@@ -279,7 +257,7 @@ static int get_subaction(struct ima_rule_entry *rule, int func)
  * change.)
  */
 int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,
-		     int flags)
+		     int flags, struct ima_action_context *ctx)
 {
 	struct ima_rule_entry *entry;
 	int action = 0, actmask = flags | (flags << 1);
@@ -295,8 +273,11 @@ int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,
 		action |= entry->flags & IMA_ACTION_FLAGS;
 
 		action |= entry->action & IMA_DO_MASK;
-		if (entry->action & IMA_APPRAISE)
+		if (entry->action & IMA_APPRAISE) {
 			action |= get_subaction(entry, func);
+			if (ctx)
+				ctx->appraise = entry; /* appraise rule */
+		}
 
 		if (entry->action & IMA_DO_MASK)
 			actmask &= ~(entry->action | entry->action << 1);
@@ -381,7 +362,8 @@ enum {
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
 	Opt_func, Opt_mask, Opt_fsmagic, Opt_uid, Opt_fowner,
-	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio
+	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio,
+	Opt_cap_drop
 };
 
 static match_table_t policy_tokens = {
@@ -404,6 +386,7 @@ static match_table_t policy_tokens = {
 	{Opt_fowner, "fowner=%s"},
 	{Opt_appraise_type, "appraise_type=%s"},
 	{Opt_permit_directio, "permit_directio"},
+	{Opt_cap_drop, "cap_drop=%s"},
 	{Opt_err, NULL}
 };
 
@@ -439,6 +422,82 @@ static void ima_log_string(struct audit_buffer *ab, char *key, char *value)
 	audit_log_format(ab, " ");
 }
 
+#define CAPNAME(name)	[name] = #name
+
+const char *const cap_names[CAP_LAST_CAP + 1] = {
+	CAPNAME(CAP_CHOWN),
+	CAPNAME(CAP_DAC_OVERRIDE),
+	CAPNAME(CAP_DAC_READ_SEARCH),
+	CAPNAME(CAP_FOWNER),
+	CAPNAME(CAP_FSETID),
+	CAPNAME(CAP_KILL),
+	CAPNAME(CAP_SETGID),
+	CAPNAME(CAP_SETUID),
+	CAPNAME(CAP_SETPCAP),
+	CAPNAME(CAP_LINUX_IMMUTABLE),
+	CAPNAME(CAP_NET_BIND_SERVICE),
+	CAPNAME(CAP_NET_BROADCAST),
+	CAPNAME(CAP_NET_ADMIN),
+	CAPNAME(CAP_NET_RAW),
+	CAPNAME(CAP_IPC_LOCK),
+	CAPNAME(CAP_IPC_OWNER),
+	CAPNAME(CAP_SYS_MODULE),
+	CAPNAME(CAP_SYS_RAWIO),
+	CAPNAME(CAP_SYS_CHROOT),
+	CAPNAME(CAP_SYS_PTRACE),
+	CAPNAME(CAP_SYS_PACCT),
+	CAPNAME(CAP_SYS_ADMIN),
+	CAPNAME(CAP_SYS_BOOT),
+	CAPNAME(CAP_SYS_NICE),
+	CAPNAME(CAP_SYS_RESOURCE),
+	CAPNAME(CAP_SYS_TIME),
+	CAPNAME(CAP_SYS_TTY_CONFIG),
+	CAPNAME(CAP_MKNOD),
+	CAPNAME(CAP_LEASE),
+	CAPNAME(CAP_AUDIT_WRITE),
+	CAPNAME(CAP_AUDIT_CONTROL),
+	CAPNAME(CAP_SETFCAP),
+	CAPNAME(CAP_MAC_OVERRIDE),
+	CAPNAME(CAP_MAC_ADMIN),
+	CAPNAME(CAP_SYSLOG),
+	CAPNAME(CAP_WAKE_ALARM),
+	CAPNAME(CAP_BLOCK_SUSPEND)
+};
+
+static int ima_parse_cap(struct ima_rule_entry *entry, char *caps)
+{
+	int i;
+	char *cap;
+
+	pr_info("DROP CAPS: %s\n", caps);
+
+	if (!strcasecmp("all", caps)) {
+		/* drop all caps */
+		entry->cap_permitted = CAP_EMPTY_SET;
+		entry->flags |= IMA_DROP_CAPS;
+		return 0;
+	}
+
+	/* start with full set, then drop */
+	entry->cap_permitted = CAP_FULL_SET;
+
+	while ((cap = strsep(&caps, ",:"))) {
+		for (i = 0; i < ARRAY_SIZE(cap_names); i++) {
+			if (!strcasecmp(cap_names[i], cap))
+				break;
+		}
+		if (i == ARRAY_SIZE(cap_names)) {
+			pr_err("error in parsing capability list\n");
+			return -EINVAL;
+		}
+		cap_lower(entry->cap_permitted, i);
+		pr_info("cap_lower: %d\n", i);
+		entry->flags |= IMA_DROP_CAPS;
+	}
+
+	return 0;
+}
+
 static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 {
 	struct audit_buffer *ab;
@@ -660,6 +719,15 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 		case Opt_permit_directio:
 			entry->flags |= IMA_PERMIT_DIRECTIO;
 			break;
+		case Opt_cap_drop:
+			if (entry->action != APPRAISE) {
+				result = -EINVAL;
+				break;
+			}
+
+			ima_log_string(ab, "cap_drop", args[0].from);
+			result = ima_parse_cap(entry, args[0].from);
+			break;
 		case Opt_err:
 			ima_log_string(ab, "UNKNOWN", p);
 			result = -EINVAL;
@@ -672,6 +740,8 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 		ima_appraise |= IMA_APPRAISE_MODULES;
 	else if (entry->func == FIRMWARE_CHECK)
 		ima_appraise |= IMA_APPRAISE_FIRMWARE;
+	else if (entry->flags & IMA_DROP_CAPS)
+		ima_appraise |= IMA_APPRAISE_DROP_CAPS;
 	audit_log_format(ab, "res=%d", !result);
 	audit_log_end(ab);
 	return result;
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index f69276a..7824adc 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -32,6 +32,7 @@
 #define IMA_PERMIT_DIRECTIO	0x02000000
 #define IMA_NEW_FILE		0x04000000
 #define EVM_DIGSIG_REQUIRED	0x08000000
+#define IMA_DROP_CAPS		0x10000000
 
 #define IMA_DO_MASK		(IMA_MEASURE | IMA_APPRAISE | IMA_AUDIT | \
 				 IMA_APPRAISE_SUBMASK)
@@ -131,6 +132,7 @@ struct integrity_iint_cache {
 	enum integrity_status ima_policy_status:4;
 	enum integrity_status evm_status:4;
 	struct ima_digest_data *ima_hash;
+	kernel_cap_t cap_permitted;
 };
 
 /* rbtree tree calls to lookup, insert, delete
-- 
2.1.4

