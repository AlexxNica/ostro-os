From 1f9e6042a59864a646fd1821cb67814f7c748a03 Mon Sep 17 00:00:00 2001
From: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date: Wed, 13 Nov 2013 20:24:59 +0200
Subject: [PATCH 22/45] ima: path support for policy definition

Currently IMA policy allows to specify objects to handle using file
ownership information and security labels. But in some cases it is
not possible using such policy to differentiate between files. All
files might have the same file ownership and the same security label.

One example is using 'appraise_type=imasig' would require signature
for all files with same ownership information and label. There is
no possibility to specify that certain object must have signature
other than labeling it differently, which might not easily possible.

Another example is desire to perform integrity checks for certain
filesystem subtree where container might be having its mount root.

Having possibility to specify path of the object to perform integrity
checks could solve those limitations.

This patch allows to specify 'path=' parameter in the  IMA policy rules.
The path is mount tree agnostic and filesystem specific. The patch uses
dentry_path() instead of d_path(). By this means path stays the same in
'bind mounts' and 'namespace' environments.

Path can be specified for files and directories using conventional  or
device specific, for example:
  appraise path=/usr/bin/passwd appraise_type=imasig
  appraise path=sdb1:/usr/sbin
  appraise path=/signed appraise_type=imasig

Without device prefix, path will match on all partitions.

Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
---
 security/integrity/ima/ima.h        |  3 +++
 security/integrity/ima/ima_api.c    | 50 +++++++++++++++++++++++++++++++++++++
 security/integrity/ima/ima_policy.c | 42 ++++++++++++++++++++++++++++---
 3 files changed, 91 insertions(+), 4 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 639a6f2..6471697 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -147,6 +147,8 @@ struct ima_rule_entry {
 	u8 fsuuid[16];
 	kuid_t uid;
 	kuid_t fowner;
+	char *path;
+	int path_len;
 	kernel_cap_t cap_permitted;
 	struct {
 		void *rule;	/* LSM file metadata specific */
@@ -179,6 +181,7 @@ int ima_store_template(struct ima_template_entry *entry, int violation,
 		       struct inode *inode, const unsigned char *filename);
 void ima_free_template_entry(struct ima_template_entry *entry);
 const char *ima_d_path(struct path *path, char **pathbuf);
+const char *ima_dentry_path(struct dentry *dentry, char **pathbuf);
 
 int ima_match_policy(struct dentry *dentry, enum ima_hooks func, int mask,
 		     int flags, struct ima_action_context *ctx);
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 1645319..2a265bc 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -327,3 +327,53 @@ const char *ima_d_path(struct path *path, char **pathbuf)
 	}
 	return pathname ?: (const char *)path->dentry->d_name.name;
 }
+
+static int prepend(char **buffer, int buflen, const char *str, int namelen)
+{
+	buflen -= namelen;
+	if (buflen < 0)
+		return -ENAMETOOLONG;
+	*buffer -= namelen;
+	memcpy(*buffer, str, namelen);
+	return 0;
+}
+
+/*
+ * ima_dentry_path - returns device related path
+ *
+ * Returns device related path in a form: sda1:/usr/ls
+ * Device related is definitive way to describe object path
+ * d_path() or d_absolute_path() are not very suitable as they
+ * return mount hierarchy and chroot specific path
+ */
+const char *ima_dentry_path(struct dentry *dentry, char **pathbuf)
+{
+	char bdname[BDEVNAME_SIZE + 1];
+	int namelen;
+	char *pathname;
+	struct super_block *sb = dentry->d_sb;
+
+	*pathbuf = __getname();
+	if (!*pathbuf)
+		return NULL;
+
+	if (sb->s_bdev)
+		bdevname(sb->s_bdev, bdname);
+	else
+		strcpy(bdname, sb->s_type->name);
+
+	namelen = strlen(bdname);
+
+	pathname = dentry_path_raw(dentry, *pathbuf, PATH_MAX - namelen - 1);
+	if (IS_ERR(pathname))
+		goto err;
+
+	prepend(&pathname, pathname - *pathbuf, ":", 1);
+	prepend(&pathname, pathname - *pathbuf, bdname, namelen);
+
+	return pathname;
+err:
+	__putname(*pathbuf);
+	*pathbuf = NULL;
+	return NULL;
+}
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index e112237..915c030 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -27,6 +27,7 @@
 #define IMA_UID		0x0008
 #define IMA_FOWNER	0x0010
 #define IMA_FSUUID	0x0020
+#define IMA_PATH	0x0040
 
 #define UNKNOWN		0
 #define MEASURE		0x0001	/* same as IMA_MEASURE */
@@ -95,6 +96,7 @@ static struct ima_rule_entry default_appraise_rules[] = {
 static LIST_HEAD(ima_default_rules);
 static LIST_HEAD(ima_policy_rules);
 static struct list_head *ima_rules;
+static bool path_rules;
 
 static DEFINE_MUTEX(ima_rules_mutex);
 
@@ -153,7 +155,8 @@ static void ima_lsm_update_rules(void)
  * Returns true on rule match, false on failure.
  */
 static bool ima_match_rules(struct ima_rule_entry *rule,
-			    struct inode *inode, enum ima_hooks func, int mask)
+			    struct inode *inode, enum ima_hooks func, int mask,
+			    const char *pathname)
 {
 	struct task_struct *tsk = current;
 	const struct cred *cred = current_cred();
@@ -175,6 +178,14 @@ static bool ima_match_rules(struct ima_rule_entry *rule,
 		return false;
 	if ((rule->flags & IMA_FOWNER) && !uid_eq(rule->fowner, inode->i_uid))
 		return false;
+	if ((rule->flags & IMA_PATH)) {
+		char *pos = (char *)pathname;
+		if (rule->path[0] == '/')
+			/* cut device part of the pathname */
+			pos = 1 + strchr(pathname, ':');
+		if (strncmp(pos, rule->path, rule->path_len))
+			return false;
+	}
 	for (i = 0; i < MAX_LSM_RULES; i++) {
 		int rc = 0;
 		u32 osid, sid;
@@ -262,13 +273,22 @@ int ima_match_policy(struct dentry *dentry, enum ima_hooks func, int mask,
 	struct inode *inode = dentry->d_inode;
 	struct ima_rule_entry *entry;
 	int action = 0, actmask = flags | (flags << 1);
+	char *pathbuf = NULL;
+	const char *pathname = NULL;
+
+	if (path_rules) {
+		/* resolve path only if we have path rules */
+		pathname = ima_dentry_path(dentry, &pathbuf);
+		if (!pathname)
+			return -ENOMEM;
+	}
 
 	list_for_each_entry(entry, ima_rules, list) {
 
 		if (!(entry->action & actmask))
 			continue;
 
-		if (!ima_match_rules(entry, inode, func, mask))
+		if (!ima_match_rules(entry, inode, func, mask, pathname))
 			continue;
 
 		action |= entry->flags & IMA_ACTION_FLAGS;
@@ -288,7 +308,8 @@ int ima_match_policy(struct dentry *dentry, enum ima_hooks func, int mask,
 		if (!actmask)
 			break;
 	}
-
+	if (pathbuf)
+		__putname(pathbuf);
 	return action;
 }
 
@@ -369,7 +390,7 @@ enum {
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
 	Opt_func, Opt_mask, Opt_fsmagic, Opt_uid, Opt_fowner,
 	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio,
-	Opt_cap_drop
+	Opt_cap_drop, Opt_path
 };
 
 static match_table_t policy_tokens = {
@@ -393,6 +414,7 @@ static match_table_t policy_tokens = {
 	{Opt_appraise_type, "appraise_type=%s"},
 	{Opt_permit_directio, "permit_directio"},
 	{Opt_cap_drop, "cap_drop=%s"},
+	{Opt_path, "path=%s"},
 	{Opt_err, NULL}
 };
 
@@ -734,6 +756,18 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 			ima_log_string(ab, "cap_drop", args[0].from);
 			result = ima_parse_cap(entry, args[0].from);
 			break;
+		case Opt_path:
+			ima_log_string(ab, "path", args[0].from);
+			entry->path_len = strlen(args[0].from);
+			entry->path = kstrdup(args[0].from, GFP_KERNEL);
+			if (entry->path) {
+				if (entry->path[entry->path_len - 1] == '/')
+					entry->path_len--; /* remove '/' */
+				entry->flags |= IMA_PATH;
+				path_rules = true; /* if we have any path rules */
+			} else
+				result = -EINVAL;
+			break;
 		case Opt_err:
 			ima_log_string(ab, "UNKNOWN", p);
 			result = -EINVAL;
-- 
2.1.4

