From 6610e89a8d2bec0aff63867a079abf5c4658f546 Mon Sep 17 00:00:00 2001
From: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date: Wed, 16 Apr 2014 10:41:50 +0300
Subject: [PATCH 16/45] evm: load EVM key from the kernel

Currently EVM key needs to be added from the user space and it has to be
done before mounting filesystems. It requires initramfs. Many systems
often does not want to use initramfs.

This patch provides support for loading EVM key from the kernel.

It supports both 'trusted' and 'user' master keys. However, it is
recommended to use 'trusted' master key, because 'user' master key
is in non-encrypted form.

Until key is loaded, EVM stays disabled. To keep default behavior, this
patch adds the kernel parameter 'evm_load' to enabled loading of the key.

It also moves EVM initialization before IMA to prevent appraisal failure
when kernel will try to access file system without initial ramfs.

Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
---
 security/integrity/evm/Kconfig      | 23 +++++++++
 security/integrity/evm/evm.h        |  1 +
 security/integrity/evm/evm_crypto.c | 97 +++++++++++++++++++++++++++++++++++++
 security/integrity/evm/evm_main.c   | 20 ++++++--
 security/integrity/iint.c           |  2 +-
 security/integrity/integrity.h      |  6 +--
 6 files changed, 142 insertions(+), 7 deletions(-)

diff --git a/security/integrity/evm/Kconfig b/security/integrity/evm/Kconfig
index 952c71a..640ae40 100644
--- a/security/integrity/evm/Kconfig
+++ b/security/integrity/evm/Kconfig
@@ -57,3 +57,26 @@ config EVM_X509_PATH
 	help
 	   This option defines X509 certificate path.
 
+config EVM_LOAD_KEY
+	bool "Load EVM HMAC key from the kernel"
+	depends on EVM
+	select INTEGRITY_FILE_READ
+	default n
+	help
+	   This option enables EVM HMAC key loading from the kernel.
+	   It enables EVM.
+
+config EVM_KEY_PATH
+	string "EVM HMAC key path"
+	depends on EVM_LOAD_KEY
+	default "/etc/ima/evm-key"
+	help
+	   This option defines EVM HMAC key path.
+
+config EVM_KMK_PATH
+	string "EVM master key path"
+	depends on EVM_LOAD_KEY
+	default "/etc/ima/evm-kmk"
+	help
+	   This option defines EVM master key path.
+
diff --git a/security/integrity/evm/evm.h b/security/integrity/evm/evm.h
index bc81f99..6bdd6c1 100644
--- a/security/integrity/evm/evm.h
+++ b/security/integrity/evm/evm.h
@@ -38,6 +38,7 @@ extern struct crypto_shash *hash_tfm;
 /* List of EVM protected security xattrs */
 extern char *evm_config_xattrnames[];
 
+int evm_load_key(const char *key, const char *kmk);
 int evm_init_key(void);
 int evm_update_evmxattr(struct dentry *dentry,
 			const char *req_xattr_name,
diff --git a/security/integrity/evm/evm_crypto.c b/security/integrity/evm/evm_crypto.c
index d4ce0c2..7cd3724 100644
--- a/security/integrity/evm/evm_crypto.c
+++ b/security/integrity/evm/evm_crypto.c
@@ -18,6 +18,8 @@
 #include <linux/module.h>
 #include <linux/crypto.h>
 #include <linux/xattr.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
 #include <keys/encrypted-type.h>
 #include <crypto/hash.h>
 #include "evm.h"
@@ -284,3 +286,98 @@ out:
 	}
 	return rc;
 }
+
+#ifdef CONFIG_EVM_LOAD_KEY
+int evm_load_key(const char *key, const char *kmk)
+{
+	key_ref_t key_ref, keyring_ref;
+	char *data, *tdata = NULL, *cmd, *type, ch = '\0';
+	int rc, len;
+	bool trusted = false;
+
+	keyring_ref = make_key_ref(current_cred()->user->uid_keyring, 1);
+
+	len = integrity_read_file(key, &data);
+	if (len < 0)
+		return len;
+
+	swap(data[len - 1], ch);
+	if (strstr(data, "trusted"))
+		trusted = true;
+	swap(data[len - 1], ch);
+
+	rc = integrity_read_file(kmk, &tdata);
+	if (rc < 0)
+		goto out;
+
+	/* padd does not like \n - remove it*/
+	if (strchr(tdata, '\n'))
+		rc--;
+
+	if (trusted) {
+		/* we need 'load' keyword */
+		cmd = kmalloc(rc + 5, GFP_KERNEL);
+		if (!cmd)
+			goto out;
+
+		memcpy(cmd, "load ", 5);
+		memcpy(cmd + 5, tdata, rc);
+		rc += 5;
+	} else {
+		cmd = tdata;
+	}
+
+	key_ref = key_create_or_update(keyring_ref,
+					trusted ? "trusted" : "user", "kmk",
+					cmd, rc,
+					((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+					KEY_USR_VIEW | KEY_USR_READ),
+					KEY_ALLOC_NOT_IN_QUOTA);
+	if (trusted)
+		kfree(cmd);
+	type = trusted ? "trusted" : "user";
+	if (IS_ERR(key_ref)) {
+		rc = PTR_ERR(key_ref);
+		pr_err("problem loading EVM kmk (%s) (%d): %s\n",
+		       type, rc, kmk);
+		goto out;
+	} else {
+		pr_notice("loaded EVM kmk (%s) %d': %s\n",
+			  type, key_ref_to_ptr(key_ref)->serial, kmk);
+		key_ref_put(key_ref);
+	}
+
+	/* padd does not like \n - remove it*/
+	if (strchr(data, '\n'))
+		len--;
+
+	/* we need 'load' keyword */
+	cmd = kmalloc(len + 5, GFP_KERNEL);
+	if (!cmd)
+		goto out;
+
+	memcpy(cmd, "load ", 5);
+	memcpy(cmd + 5, data, len);
+
+	key_ref = key_create_or_update(keyring_ref,
+					"encrypted", EVMKEY, cmd, len + 5,
+					((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+					KEY_USR_VIEW | KEY_USR_READ),
+					KEY_ALLOC_NOT_IN_QUOTA);
+	kfree(cmd);
+	if (IS_ERR(key_ref)) {
+		rc = PTR_ERR(key_ref);
+		pr_err("problem loading EVM key (%d): %s\n", rc, key);
+	} else {
+		pr_notice("loaded EVM key %d': %s\n",
+			  key_ref_to_ptr(key_ref)->serial, key);
+		key_ref_put(key_ref);
+		rc = evm_init_key();
+	}
+
+out:
+	kfree(tdata);
+	kfree(data);
+	return rc;
+}
+#endif
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 0666f6d..a271af0 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -68,6 +68,14 @@ static int __init evm_set_fixmode(char *str)
 }
 __setup("evm=", evm_set_fixmode);
 
+static int evm_load;
+static int __init evm_load_setup(char *str)
+{
+	evm_load = 1;
+	return 0;
+}
+__setup("evm_load", evm_load_setup);
+
 static void __init evm_init_config(void)
 {
 #ifdef CONFIG_EVM_ATTR_FSUUID
@@ -497,16 +505,22 @@ out:
 }
 EXPORT_SYMBOL_GPL(evm_inode_init_security);
 
-#ifdef CONFIG_EVM_LOAD_X509
-void __init evm_load_x509(void)
+void __init evm_load_keys(void)
 {
 	int rc;
 
+	rc = 0; /* suppress unused warning */
+
+#ifdef CONFIG_EVM_LOAD_X509
 	rc = integrity_load_x509(INTEGRITY_KEYRING_EVM, EVM_X509_PATH);
 	if (!rc)
 		evm_initialized |= EVM_STATE_X509_SET;
-}
 #endif
+#ifdef CONFIG_EVM_LOAD_KEY
+	if (evm_load)
+		evm_load_key(CONFIG_EVM_KEY_PATH, CONFIG_EVM_KMK_PATH);
+#endif
+}
 
 static int __init init_evm(void)
 {
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 929b4e3..6687bf1 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -262,5 +262,5 @@ out_fput:
 void __init integrity_load_keys(void)
 {
 	ima_load_x509();
-	evm_load_x509();
+	evm_load_keys();
 }
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index c55c015..f69276a 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -194,10 +194,10 @@ static inline void ima_load_x509(void)
 }
 #endif
 
-#ifdef CONFIG_EVM_LOAD_X509
-void __init evm_load_x509(void);
+#ifdef CONFIG_EVM
+void __init evm_load_keys(void);
 #else
-static inline void evm_load_x509(void)
+static inline void evm_load_keys(void)
 {
 }
 #endif
-- 
2.1.4

